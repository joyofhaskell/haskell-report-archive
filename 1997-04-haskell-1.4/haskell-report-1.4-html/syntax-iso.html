
<title>Haskell 1.4 Syntax</title>
<body bgcolor="#ffffff"> <i>The Haskell 1.4 Report</i><br> <a href="index.html">top</a> | <a href="standard-prelude.html">back</a> | <a href="literate.html">next</a> | <a href="index14.html">contents</a> | <a href="prelude-index.html">function index</a> <br><hr>
<a name="syntax"></a><a name="sectB"></a>
<h2>B<tt>&nbsp;&nbsp;</tt>Syntax</h2>
<p>
<a name="sectB.1"></a>
<h3>B.1<tt>&nbsp;&nbsp;</tt>Notational Conventions</h3><p>
These notational conventions are used for presenting syntax:<p>
<p>
<table >
<tr><td align=center>
<I>[pattern]</I>		</td><td> optional </td></tr><tr><td align=center><I>{pattern}</I>		</td><td> zero or more repetitions </td></tr><tr><td align=center><I>(pattern)</I>		</td><td> grouping </td></tr><tr><td align=center><I>pat</I><sub><I>1</I></sub><I> | pat</I><sub><I>2</I></sub>		</td><td> choice </td></tr><tr><td align=center><I>pat</I><sub><I>&lt;pat'&gt;</I></sub>	</td><td> difference---elements generated by <I>pat</I> </td></tr><tr><td align=center></td><td> except those generated by <I>pat'</I> </td></tr><tr><td align=center><tt>fibonacci</tt>		</td><td> terminal syntax in typewriter font
</td></tr></table>
<p>
<p>
BNF-like syntax is used throughout, with productions having the form:
<table cellspacing=0 cellspacing=0>
<tr><td width=100>
nonterm </td><td width=20>  <tt>-&gt;</tt> </td><td width=250> alt<sub>1</sub> | alt<sub>2</sub> | ... | alt<sub>n</sub>
</td></tr></table>
<p>
There are some families of nonterminals indexed by
precedence levels (written as a superscript).  Similarly, the
nonterminals <I>op</I>, <I>varop</I>, and <I>conop</I> may have a double index:
a letter <I>l</I>, <I>r</I>, or <I>n</I> for left-, right- or nonassociativity and
a precedence level.  A precedence-level variable <I>i</I> ranges from 0 to 9;
an associativity variable <I>a</I> varies over <I>{l, r, n}</I>.
Thus, for example
<table cellspacing=0 cellspacing=0>
<tr><td width=100>
aexp </td><td width=20>  <tt>-&gt;</tt> </td><td width=250>  <tt>(</tt> exp<sub>i+1</sub> qop<sub>(a,i)</sub> <tt>)
</tt></td></tr></table>
actually stands for 30 productions, with 10 substitutions for <I>i
</I>and 3 for <I>a</I>.<p>
In both the lexical and the context-free syntax, there are some
ambiguities that are to be resolved by making grammatical phrases as
long as possible, proceeding from left to right (in shift-reduce
parsing, resolving shift/reduce conflicts by shifting).  In the lexical
syntax, this is the "consume longest lexeme" rule.  In the
context-free syntax, this means that conditionals, let-expressions, and
lambda abstractions extend to the right as far as possible.<p>
<a name="sectB.2"></a>
<h3>B.2<tt>&nbsp;&nbsp;</tt>Lexical Syntax</h3><p>
<table cellspacing=0 cellspacing=0>
<tr><td width=100></td><td width=20></td><td width=250></td></tr><tr></tr><tr></tr><tr></tr><tr><td>
program </td><td>  <tt>-&gt;</tt> </td><td> {lexeme | whitespace }
</td></tr><tr><td>
lexeme </td><td>  <tt>-&gt;</tt> </td><td> varid | conid | varsym | consym | literal | special | reservedop | reservedid
</td></tr><tr><td>
literal </td><td>  <tt>-&gt;</tt> </td><td> integer | float | char | string
</td></tr><tr><td>
special </td><td>  <tt>-&gt;</tt> </td><td> <tt>(</tt> | <tt>)</tt> | <tt>,</tt> | <tt>;</tt> | <tt>[</tt> | <tt>]</tt> | <tt>_</tt> | `| <tt>{</tt> | <tt>}
</tt></td></tr><tr><td>
whitespace </td><td>  <tt>-&gt;</tt> </td><td> whitestuff {whitestuff}
</td></tr><tr><td>
whitestuff </td><td>  <tt>-&gt;</tt> </td><td> whitechar | comment | ncomment
</td></tr><tr><td>
whitechar </td><td>  <tt>-&gt;</tt> </td><td> newline | return | linefeed | vertab | formfeed
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td> space | tab | UNIwhite
</td></tr><tr><td>
newline </td><td>  <tt>-&gt;</tt> </td><td> a newline (system dependent)
</td></tr><tr><td>
return </td><td>  <tt>-&gt;</tt> </td><td> a carriage return
</td></tr><tr><td>
linefeed </td><td>  <tt>-&gt;</tt> </td><td> a line feed
</td></tr><tr><td>
space </td><td>  <tt>-&gt;</tt> </td><td> a space
</td></tr><tr><td>
tab </td><td>  <tt>-&gt;</tt> </td><td> a horizontal tab
</td></tr><tr><td>
vertab </td><td>  <tt>-&gt;</tt> </td><td> a vertical tab
</td></tr><tr><td>
formfeed </td><td>  <tt>-&gt;</tt> </td><td> a form feed
</td></tr><tr><td>
uniWhite </td><td>  <tt>-&gt;</tt> </td><td> any UNIcode character defined as whitespace
</td></tr><tr><td>
comment </td><td>  <tt>-&gt;</tt> </td><td> <tt>--</tt> {any}newline
</td></tr><tr><td>
ncomment </td><td>  <tt>-&gt;</tt> </td><td> <tt>{-</tt> ANYseq {ncomment ANYseq}<tt>-}
</tt></td></tr><tr><td>
ANYseq </td><td>  <tt>-&gt;</tt> </td><td> {ANY}<sub>&lt;{ANY}( <tt>{-</tt> | <tt>-}</tt> ) {ANY}&gt;</sub>
</td></tr><tr><td>
ANY </td><td>  <tt>-&gt;</tt> </td><td> any | newline | vertab | formfeed
</td></tr><tr><td>
any </td><td>  <tt>-&gt;</tt> </td><td> graphic | space | tab | nonbrkspc
</td></tr><tr><td>
graphic </td><td>  <tt>-&gt;</tt> </td><td> large | small | digit | symbol | special | <tt>:</tt> | <tt>"</tt> | <tt>'
</tt></td></tr><tr><td>
small </td><td>  <tt>-&gt;</tt> </td><td> ASCsmall | UNIsmall
</td></tr><tr><td>
ASCsmall </td><td>  <tt>-&gt;</tt> </td><td> <tt>a</tt> | <tt>b</tt> | ... | <tt>z
</tt></td></tr><tr><td>
UNIsmall </td><td>  <tt>-&gt;</tt> </td><td> any Unicode lowercase letter
</td></tr><tr><td>
large </td><td>  <tt>-&gt;</tt> </td><td> ASClarge | UNIlarge
</td></tr><tr><td>
ASClarge </td><td>  <tt>-&gt;</tt> </td><td> <tt>A</tt> | <tt>B</tt> | ... | <tt>Z
</tt></td></tr><tr><td>
UNIlarge </td><td>  <tt>-&gt;</tt> </td><td> any uppercase or titlecase Unicode letter
</td></tr><tr><td>
symbol </td><td>  <tt>-&gt;</tt> </td><td> ASCsymbol | UNIsymbol
</td></tr><tr><td>
ASCsymbol </td><td>  <tt>-&gt;</tt> </td><td> <tt>!</tt> | <tt>#</tt> | <tt>$</tt> | <tt>%</tt> | <tt>&amp;</tt> | <tt>*</tt> | <tt>+</tt> | <tt>.</tt> | <tt>/</tt> | <tt>&lt;</tt> | <tt>=</tt> | <tt>&gt;</tt> | <tt>?</tt> | @
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>\</tt> | <tt>^</tt> | <tt>|</tt> | <tt>-</tt> | <tt>~
</tt></td></tr><tr><td>
UNIsymbol </td><td>  <tt>-&gt;</tt> </td><td> Any Unicode symbol or punctuation
</td></tr><tr><td>
digit </td><td>  <tt>-&gt;</tt> </td><td> <tt>0</tt> | <tt>1</tt> | ... | <tt>9
</tt></td></tr><tr><td>
udigit </td><td>  <tt>-&gt;</tt> </td><td> digit | UNIdigit
</td></tr><tr><td>
UNIdigit </td><td>  <tt>-&gt;</tt> </td><td> A Unicode numberic
</td></tr><tr><td>
octit </td><td>  <tt>-&gt;</tt> </td><td> <tt>0</tt> | <tt>1</tt> | ... | <tt>7
</tt></td></tr><tr><td>
hexit </td><td>  <tt>-&gt;</tt> </td><td> digit | <tt>A</tt> | ... | <tt>F</tt> | <tt>a</tt> | ... | <tt>f
</tt></td></tr></table>
<p>
<table cellspacing=0 cellspacing=0>
<tr><td width=100></td><td width=20></td><td width=250></td></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr><td>
varid </td><td>  <tt>-&gt;</tt> </td><td> (small {small | large | udigit | <tt>'</tt> | <tt>_</tt>})<sub>&lt;reservedid&gt;</sub>
</td></tr><tr><td>
conid </td><td>  <tt>-&gt;</tt> </td><td> large {small | large | udigit | <tt>'</tt> | <tt>_</tt>}
</td></tr><tr><td>
reservedid </td><td>  <tt>-&gt;</tt> </td><td> <tt>case</tt> | <tt>class</tt> | <tt>data</tt> | <tt>default</tt> | <tt>deriving</tt> | <tt>do</tt> | <tt>else
</tt></td></tr><tr><td>
</td><td> <tt>|</tt> </td><td> <tt>if</tt> | <tt>import</tt> | <tt>in</tt> | <tt>infix</tt> | <tt>infixl</tt> | <tt>infixr</tt> | <tt>instance
</tt></td></tr><tr><td>
</td><td> <tt>|</tt> </td><td> <tt>let</tt> | <tt>module</tt> | <tt>newtype</tt> | <tt>of</tt> | <tt>then</tt> | <tt>type</tt> | <tt>where
</tt></td></tr><tr><td>
specialid </td><td>  <tt>-&gt;</tt> </td><td> <tt>as</tt> | <tt>qualified</tt> | <tt>hiding
</tt></td></tr><tr><td>
varsym </td><td>  <tt>-&gt;</tt> </td><td> ( symbol {symbol | <tt>:</tt>})<sub>&lt;reservedop&gt;</sub>
</td></tr><tr><td>
consym </td><td>  <tt>-&gt;</tt> </td><td> (<tt>:</tt> {symbol | <tt>:</tt>})<sub>&lt;reservedop&gt;</sub>
</td></tr><tr><td>
reservedop </td><td>  <tt>-&gt;</tt> </td><td> <tt>..</tt> | <tt>::</tt> | <tt>=</tt> | <tt>\</tt> | <tt>|</tt> | <tt>&lt;-</tt> | <tt>-&gt;</tt> | <tt>@</tt> | <tt>~</tt> | <tt>=&gt;
</tt></td></tr><tr><td>
specialop </td><td>  <tt>-&gt;</tt> </td><td> <tt>-</tt> | <tt>!
</tt></td></tr><tr><td>
varid </td><td> </td><td></td><td> (variables)
</td></tr><tr><td>
conid </td><td> </td><td></td><td> (constructors)
</td></tr><tr><td>
tyvar </td><td>  <tt>-&gt;</tt> </td><td>  varid	</td><td> (type variables)
</td></tr><tr><td>
tycon </td><td>  <tt>-&gt;</tt> </td><td>  conid 	</td><td> (type constructors)
</td></tr><tr><td>
tycls </td><td>  <tt>-&gt;</tt> </td><td>  conid 	</td><td> (type classes)
</td></tr><tr><td>
modid </td><td>  <tt>-&gt;</tt> </td><td>  conid	</td><td> (modules)
</td></tr><tr><td>
qvarid </td><td>  <tt>-&gt;</tt> </td><td> [ modid <tt>.</tt> ] varid
</td></tr><tr><td>
qconid </td><td>  <tt>-&gt;</tt> </td><td> [ modid <tt>.</tt> ] conid
</td></tr><tr><td>
qtycon </td><td>  <tt>-&gt;</tt> </td><td> [ modid <tt>.</tt> ] tycon
</td></tr><tr><td>
qtycls </td><td>  <tt>-&gt;</tt> </td><td> [ modid <tt>.</tt> ] tycls
</td></tr><tr><td>
qvarsym </td><td>  <tt>-&gt;</tt> </td><td> [ modid <tt>.</tt> ] varsym
</td></tr><tr><td>
qconsym </td><td>  <tt>-&gt;</tt> </td><td> [ modid <tt>.</tt> ] consym
</td></tr><tr><td>
decimal </td><td>  <tt>-&gt;</tt> </td><td> digit{digit}
</td></tr><tr><td>
octal </td><td>  <tt>-&gt;</tt> </td><td> octit{octit}
</td></tr><tr><td>
hexadecimal </td><td>  <tt>-&gt;</tt> </td><td> hexit{hexit}
</td></tr><tr><td>
integer </td><td>  <tt>-&gt;</tt> </td><td> decimal
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>0o</tt> octal | <tt>0O</tt> octal
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>0x</tt> hexadecimal | <tt>0X</tt> hexadecimal
</td></tr><tr><td>
float </td><td>  <tt>-&gt;</tt> </td><td> decimal <tt>.</tt> decimal[(<tt>e</tt> | <tt>E</tt>)[<tt>-</tt> | <tt>+</tt>]decimal]
</td></tr><tr><td>
char </td><td>  <tt>-&gt;</tt> </td><td>  <tt>'</tt> (graphic<sub>&lt;<tt>'</tt> | <tt>\</tt>&gt;</sub> | space | escape<sub>&lt;<tt>\&amp;</tt>&gt;</sub>) <tt>'
</tt></td></tr><tr><td>
string </td><td>  <tt>-&gt;</tt> </td><td>  <tt>"</tt> {graphic<sub>&lt;<tt>"</tt>  | <tt>\</tt>&gt;</sub> | space | escape | gap}<tt>"
</tt></td></tr><tr><td>
escape </td><td>  <tt>-&gt;</tt> </td><td>  <tt>\</tt> ( charesc | ascii | decimal | <tt>o</tt> octal | <tt>x</tt> hexadecimal )
</td></tr><tr><td>
charesc </td><td>  <tt>-&gt;</tt> </td><td> <tt>a</tt> | <tt>b</tt> | <tt>f</tt> | <tt>n</tt> | <tt>r</tt> | <tt>t</tt> | <tt>v</tt> | <tt>\</tt> | <tt>"</tt> | <tt>'</tt> | <tt>&amp;
</tt></td></tr><tr><td>
ascii </td><td>  <tt>-&gt;</tt> </td><td> <tt>^</tt>cntrl | <tt>NUL</tt> | <tt>SOH</tt> | <tt>STX</tt> | <tt>ETX</tt> | <tt>EOT</tt> | <tt>ENQ</tt> | <tt>ACK</tt> 
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td> <tt>BEL</tt> | <tt>BS</tt> | <tt>HT</tt> | <tt>LF</tt> | <tt>VT</tt> | <tt>FF</tt> | <tt>CR</tt> | <tt>SO</tt> | <tt>SI</tt> | <tt>DLE</tt> 
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td> <tt>DC1</tt> | <tt>DC2</tt> | <tt>DC3</tt> | <tt>DC4</tt> | <tt>NAK</tt> | <tt>SYN</tt> | <tt>ETB</tt> | <tt>CAN</tt> 
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td> <tt>EM</tt> | <tt>SUB</tt> | <tt>ESC</tt> | <tt>FS</tt> | <tt>GS</tt> | <tt>RS</tt> | <tt>US</tt> | <tt>SP</tt> | <tt>DEL
</tt></td></tr><tr><td>
cntrl </td><td>  <tt>-&gt;</tt> </td><td> ASClarge | @ | <tt>[</tt> | <tt>\</tt> | <tt>]</tt> | <tt>^</tt> | <tt>_
</tt></td></tr><tr><td>
gap </td><td>  <tt>-&gt;</tt> </td><td>  <tt>\</tt> whitechar {whitechar}<tt>\
</tt></td></tr></table>
<a name="layout"></a><p>
<a name="sectB.3"></a>
<h3>B.3<tt>&nbsp;&nbsp;</tt>Layout</h3>
<p>
Definitions: The indentation of a lexeme is the column number
indicating the start of that lexeme; the indentation of a line is the
indentation of its leftmost lexeme.  To determine the column number,
assume a fixed-width font with this tab convention: tab stops
are 8 characters apart, and a tab character causes the insertion of
enough spaces to align the current position with the next tab stop.<p>
In the syntax given in the rest of the report, <I>layout 
lists</I> are always preceded by the keyword <tt>where</tt>, <tt>let</tt>, <tt>do</tt>,
or <tt>of</tt>, and are
enclosed within curly braces (<tt>{&nbsp;}</tt>) with the individual declarations
separated by semicolons (<tt>;</tt>).  Layout lists usually contain
declarations, but <tt>do</tt> and <tt>case</tt> introduce lists of other sorts.
For example, the syntax of a <tt>let
</tt>expression is:
<p>

<tt>let&nbsp;{</tt> decl<sub>1</sub> <tt>;</tt> decl<sub>2</sub> <tt>;</tt> ... <tt>;</tt> decl<sub>n</sub> [<tt>;</tt>] <tt>}&nbsp;in</tt> exp
<p>
<p>
Haskell  permits the omission of the braces and semicolons by
using <I>layout</I> to convey the same information.  This allows both
layout-sensitive and -insensitive styles of coding, which
can be freely mixed within one program.  Because layout is
not required, Haskell  programs can be straightforwardly
produced by other programs.<p>
The layout (or "off-side") rule takes effect
whenever the open brace is omitted after the keyword <tt>where</tt>, <tt>let</tt>,
<tt>do</tt>, or
<tt>of</tt>.  When this happens, the indentation of the next lexeme (whether
or not on a new line) is remembered and the omitted open brace is
inserted (the whitespace preceding the lexeme may include comments).
For each subsequent line, if it contains only whitespace or is
indented more, then the previous item is continued (nothing is
inserted); if it is indented the same amount, then a new item begins
(a semicolon is inserted); and if it is indented less, then the
layout list ends (a close brace is inserted).  A close brace is
also inserted whenever the syntactic category containing the
layout list ends; that is, if an illegal lexeme is encountered at
a point where a close brace would be legal, a close brace is inserted.
The layout rule matches only those open braces that it has
inserted; an explicit open brace must be matched by
an explicit close brace.  Within these explicit open braces,
<I>no</I> layout processing is performed for constructs outside the
braces, even if a line is 
indented to the left of an earlier implicit open brace.<p>
Given these rules, a single newline may actually terminate several
layout lists.  Also, these rules permit:
<tt><br>

<br>
f&nbsp;x&nbsp;=&nbsp;let&nbsp;a&nbsp;=&nbsp;1;&nbsp;b&nbsp;=&nbsp;2&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g&nbsp;y&nbsp;=&nbsp;exp2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in&nbsp;exp1<br>

<br>

</tt>making <tt>a</tt>, <tt>b</tt> and <tt>g</tt> all part of the same layout
list.<p>
To facilitate the use of layout at the top level of a module
(an implementation may allow several modules may reside in one file),
the keyword 
<tt>module</tt> and the end-of-file token are assumed to occur in column
0 (whereas normally the first column is 1).  Otherwise, all
top-level declarations would have to be indented.<p>
Section <a href="intro.html#lexemes-layout">1.5</a> gives an example that uses the layout
rule.<a name="bnf"></a><p>

<a name="sectB.4"></a>
<h3>B.4<tt>&nbsp;&nbsp;</tt>Context-Free Syntax</h3>

<table cellspacing=0 cellspacing=0>
<tr><td width=100></td><td width=20></td><td width=250></td></tr><tr><td>
module </td><td>  <tt>-&gt;</tt> </td><td> <tt>module</tt> modid [exports] <tt>where</tt> body
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  body
</td></tr><tr><td>
body </td><td>  <tt>-&gt;</tt> </td><td> <tt>{</tt> [impdecls <tt>;</tt>] [[fixdecls <tt>;</tt>] topdecls [<tt>;</tt>]] <tt>}
</tt></td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>{</tt> impdecls [<tt>;</tt>] <tt>}
</tt></td></tr><tr><td>
impdecls </td><td>  <tt>-&gt;</tt> </td><td> impdecl<sub>1</sub> <tt>;</tt> ... <tt>;</tt> impdecl<sub>n</sub> 	</td><td> <tt>&nbsp;&nbsp;</tt>(n&gt;=1)
</td></tr></table>
<p>
<table cellspacing=0 cellspacing=0>
<tr><td width=100></td><td width=20></td><td width=250></td></tr><tr><td>
exports </td><td>  <tt>-&gt;</tt> </td><td> <tt>(</tt> export<sub>1</sub> <tt>,</tt> ... <tt>,</tt> export<sub>n</sub> [ <tt>,</tt> ] <tt>)</tt> </td><td> <tt>&nbsp;&nbsp;</tt>(n&gt;=0)
</td></tr><tr><td>
export </td><td>  <tt>-&gt;</tt> </td><td> qvar
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  qtycon [<tt>(..)</tt> | <tt>(</tt> qcname<sub>1</sub> <tt>,</tt> ... <tt>,</tt> qcname<sub>n</sub> <tt>)</tt>] </td><td> <tt>&nbsp;&nbsp;</tt>(n&gt;=0)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  qtycls [<tt>(..)</tt> | <tt>(</tt> qvar<sub>1</sub> <tt>,</tt> ... <tt>,</tt> qvar<sub>n</sub> <tt>)</tt>] </td><td> <tt>&nbsp;&nbsp;</tt>(n&gt;=0)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>module</tt> modid
</td></tr><tr><td>
qcname </td><td>  <tt>-&gt;</tt> </td><td> qvar | qcon
</td></tr></table>
<p>
<table cellspacing=0 cellspacing=0>
<tr><td width=100></td><td width=20></td><td width=250></td></tr><tr><td>
impdecl </td><td>  <tt>-&gt;</tt> </td><td> <tt>import</tt> [<tt>qualified</tt>] modid [<tt>as</tt> modid] [impspec]
</td></tr><tr><td>
impspec </td><td>  <tt>-&gt;</tt> </td><td> <tt>(</tt> import<sub>1</sub> <tt>,</tt> ... <tt>,</tt> import<sub>n</sub> [ <tt>,</tt> ] <tt>)</tt> </td><td> <tt>&nbsp;&nbsp;</tt>(n&gt;=0)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>hiding</tt> <tt>(</tt> import<sub>1</sub> <tt>,</tt> ... <tt>,</tt> import<sub>n</sub> [ <tt>,</tt> ] <tt>)</tt> </td><td> <tt>&nbsp;&nbsp;</tt>(n&gt;=0)
</td></tr><tr><td>
import </td><td>  <tt>-&gt;</tt> </td><td> var
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  tycon [ <tt>(..)</tt> | <tt>(</tt> cname<sub>1</sub> <tt>,</tt> ... <tt>,</tt> cname<sub>n</sub> <tt>)</tt>] </td><td> <tt>&nbsp;&nbsp;</tt>(n&gt;=1)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  tycls [<tt>(..)</tt> | <tt>(</tt> var<sub>1</sub> <tt>,</tt> ... <tt>,</tt> var<sub>n</sub> <tt>)</tt>] </td><td> <tt>&nbsp;&nbsp;</tt>(n&gt;=0)
</td></tr><tr><td>
cname </td><td>  <tt>-&gt;</tt> </td><td> var | con
</td></tr></table>
<table cellspacing=0 cellspacing=0>
<tr><td width=100>
fixdecls </td><td width=20>  <tt>-&gt;</tt> </td><td width=250> fix<sub>1</sub> <tt>;</tt> ... <tt>;</tt> fix<sub>n</sub> 		</td><td> <tt>&nbsp;&nbsp;</tt>(n&gt;=1)
</td></tr><tr><td>
fix </td><td>  <tt>-&gt;</tt> </td><td> <tt>infixl</tt> [digit] ops 
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td> <tt>infixr</tt> [digit] ops
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td> <tt>infix&nbsp;</tt> [digit] ops 
</td></tr><tr><td>
ops </td><td>  <tt>-&gt;</tt> </td><td> op<sub>1</sub> <tt>,</tt> ... <tt>,</tt> op<sub>n</sub>		</td><td> <tt>&nbsp;&nbsp;</tt>(n&gt;=1)
</td></tr></table>
<p>
<table cellspacing=0 cellspacing=0>
<tr><td width=100></td><td width=20></td><td width=250></td></tr><tr></tr><tr></tr><tr><td>
topdecls </td><td>  <tt>-&gt;</tt> </td><td> topdecl<sub>1</sub> <tt>;</tt> ... <tt>;</tt> topdecl<sub>n</sub> 	</td><td> <tt>&nbsp;&nbsp;</tt>(n&gt;=0)
</td></tr><tr><td>
topdecl </td><td>  <tt>-&gt;</tt> </td><td> <tt>type</tt> simpletype <tt>=</tt> type
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>data</tt> [context <tt>=&gt;</tt>] simpletype <tt>=</tt> constrs [deriving]
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>newtype</tt> [context <tt>=&gt;</tt>] simpletype <tt>=</tt> con atype [deriving]
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>class</tt> [context <tt>=&gt;</tt>] simpleclass [<tt>where</tt> <tt>{</tt> cbody [<tt>;</tt>] <tt>}</tt>]
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>instance</tt> [context <tt>=&gt;</tt>] qtycls inst [<tt>where</tt> <tt>{</tt> valdefs [<tt>;</tt>] <tt>}</tt>]
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>default</tt> <tt>(</tt>type<sub>1</sub> <tt>,</tt> ... <tt>,</tt> type<sub>n</sub><tt>)</tt> </td><td> <tt>&nbsp;&nbsp;</tt>(n&gt;=0)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  decl
</td></tr><tr><td>
decls </td><td>  <tt>-&gt;</tt> </td><td> decl<sub>1</sub> <tt>;</tt> ... <tt>;</tt> decl<sub>n</sub>		</td><td> <tt>&nbsp;&nbsp;</tt>(n&gt;=0)
</td></tr><tr><td>
decl </td><td>  <tt>-&gt;</tt> </td><td> signdecl
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  valdef
</td></tr><tr><td>
decllist </td><td>  <tt>-&gt;</tt> </td><td> <tt>{</tt> decls [<tt>;</tt>] <tt>}
</tt></td></tr><tr><td>
signdecl </td><td>  <tt>-&gt;</tt> </td><td> vars <tt>::</tt> [context <tt>=&gt;</tt>] type
</td></tr><tr><td>
vars </td><td>  <tt>-&gt;</tt> </td><td> var<sub>1</sub> <tt>,</tt> ...<tt>,</tt> var<sub>n</sub>			</td><td> (n&gt;=1)
</td></tr></table>
<p>
<table cellspacing=0 cellspacing=0>
<tr><td width=100></td><td width=20></td><td width=250></td></tr><tr></tr><tr></tr><tr></tr><tr><td>
type </td><td>  <tt>-&gt;</tt> </td><td> btype [<tt>-&gt;</tt> type]                    </td><td> (function type)
</td></tr><tr><td>
btype </td><td>  <tt>-&gt;</tt> </td><td>  [btype] atype                        </td><td> (type application)
</td></tr><tr><td>
atype </td><td>  <tt>-&gt;</tt> </td><td>  gtycon
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  tyvar
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>(</tt> type<sub>1</sub> <tt>,</tt> ... <tt>,</tt> type<sub>k</sub> <tt>)</tt> </td><td> (tuple type, k&gt;=2)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>[</tt> type <tt>]</tt>                      </td><td> (list type)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>(</tt> type <tt>)</tt>                      </td><td> (parenthesized constructor)
</td></tr><tr><td>
gtycon </td><td>  <tt>-&gt;</tt> </td><td> qtycon
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>()</tt>                              </td><td> (unit type)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>[]</tt>                              </td><td> (list constructor)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>(-&gt;)</tt>                            </td><td> (function constructor)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>(,</tt>{<tt>,</tt>}<tt>)</tt>                    </td><td> (tupling constructors)
</td></tr><tr><td>
context </td><td>  <tt>-&gt;</tt> </td><td> class
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>(</tt> class<sub>1</sub> <tt>,</tt> ... <tt>,</tt> class<sub>n</sub> <tt>)</tt>		</td><td> (n&gt;=1)
</td></tr><tr><td>
class </td><td>  <tt>-&gt;</tt> </td><td> qtycls tyvar			
</td></tr></table>
<table cellspacing=0 cellspacing=0>
<tr><td width=100>
simpletype </td><td width=20>  <tt>-&gt;</tt> </td><td width=250> tycon tyvar<sub>1</sub> ... tyvar<sub>k</sub> </td><td> (k&gt;=0)
</td></tr><tr><td>
constrs </td><td>  <tt>-&gt;</tt> </td><td> constr<sub>1</sub> <tt>|</tt> ... <tt>|</tt> constr<sub>n</sub>	</td><td> (n&gt;=1)
</td></tr><tr><td>
constrs </td><td>  <tt>-&gt;</tt> </td><td> constr<sub>1</sub> <tt>|</tt> ... <tt>|</tt> constr<sub>n</sub>	</td><td> (n&gt;=1)
</td></tr><tr><td>
constr </td><td>  <tt>-&gt;</tt> </td><td> con [<tt>!</tt>] atype<sub>1</sub> ... [<tt>!</tt>] atype<sub>k</sub>	</td><td> (arity con = k, k&gt;=0)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  (btype | <tt>!</tt> atype) conop (btype | <tt>!</tt> atype) </td><td> (infix conop)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  con <tt>{</tt> fielddecl<sub>1</sub> <tt>,</tt> ... <tt>,</tt> fielddecl<sub>n</sub> <tt>}</tt> </td><td> (n&gt;=1)
</td></tr><tr><td>
fielddecl </td><td>  <tt>-&gt;</tt> </td><td> vars <tt>::</tt> (type | <tt>!</tt> atype)
</td></tr><tr><td>
deriving </td><td>  <tt>-&gt;</tt> </td><td> <tt>deriving</tt> (dclass | <tt>(</tt>dclass<sub>1</sub><tt>,</tt> ... <tt>,</tt> dclass<sub>n</sub><tt>)</tt>)</td><td> (n&gt;=0)
</td></tr><tr><td>
dclass </td><td>  <tt>-&gt;</tt> </td><td> qtycls
</td></tr></table>
<p>
<table cellspacing=0 cellspacing=0>
<tr><td width=100></td><td width=20></td><td width=250></td></tr><tr><td>
simpleclass </td><td>  <tt>-&gt;</tt> </td><td> tycls tyvar			
</td></tr><tr><td>
cbody </td><td>  <tt>-&gt;</tt> </td><td> [ cmethods [ ; cdefaults ] ]
</td></tr><tr><td>
cmethods </td><td>  <tt>-&gt;</tt> </td><td>  signdecl<sub>1</sub> <tt>;</tt> ... <tt>;</tt> signdecl<sub>n</sub>          </td><td> (n &gt;= 1)
</td></tr><tr><td>
cdefaults </td><td>  <tt>-&gt;</tt> </td><td>  valdef<sub>1</sub> <tt>;</tt> ... <tt>;</tt> valdef<sub>n</sub>              </td><td> (n &gt;= 1)
</td></tr></table>
<p>
<table cellspacing=0 cellspacing=0>
<tr><td width=100>
inst </td><td width=20>  <tt>-&gt;</tt> </td><td width=250> gtycon
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>(</tt> gtycon tyvar<sub>1</sub> ... tyvar<sub>k</sub> <tt>)</tt>	</td><td> (k&gt;=0, tyvars distinct)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>(</tt> tyvar<sub>1</sub> <tt>,</tt> ... <tt>,</tt> tyvar<sub>k</sub> <tt>)</tt>	</td><td> (k&gt;=2, tyvars distinct)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>[</tt> tyvar <tt>]
</tt></td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>(</tt> tyvar<sub>1</sub> <tt>-&gt;</tt> tyvar<sub>2</sub> <tt>)</tt>		</td><td> tyvar<sub>1</sub> and tyvar<sub>2</sub> distinct
</td></tr><tr><td>
valdefs </td><td>  <tt>-&gt;</tt> </td><td>  valdef<sub>1</sub> <tt>;</tt> ... <tt>;</tt> valdef<sub>n</sub> 	</td><td> (n&gt;=0)
</td></tr></table>
<p>
<table cellspacing=0 cellspacing=0>
<tr><td width=100></td><td width=20></td><td width=250></td></tr><tr></tr><tr></tr><tr></tr><tr><td>
valdef </td><td>  <tt>-&gt;</tt> </td><td>  lhs <tt>=</tt> exp [<tt>where</tt> decllist]
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   lhs gdrhs [<tt>where</tt> decllist]
</td></tr><tr><td>
lhs </td><td>  <tt>-&gt;</tt> </td><td>  pat<sub>0</sub>
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   funlhs
</td></tr><tr><td>
funlhs </td><td>  <tt>-&gt;</tt> </td><td>  var apat {apat }
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   pat<sub>i+1</sub> varop<sub>(a,i)</sub> pat<sub>i+1</sub>
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   lpat<sub>i</sub> varop<sub>(l,i)</sub> pat<sub>i+1</sub>
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   pat<sub>i+1</sub> varop<sub>(r,i)</sub> rpat<sub>i</sub>
</td></tr><tr><td>
gdrhs </td><td>  <tt>-&gt;</tt> </td><td>  gd <tt>=</tt> exp [gdrhs]
</td></tr><tr><td>
gd </td><td>  <tt>-&gt;</tt> </td><td>  <tt>|</tt> exp<sub>0</sub> 
</td></tr></table>
<p>
<table cellspacing=0 cellspacing=0>
<tr><td width=100>
exp </td><td width=20>  <tt>-&gt;</tt> </td><td width=250>  exp<sub>0</sub> <tt>::</tt> [context <tt>=&gt;</tt>] type	</td><td> (expression type signature)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   exp<sub>0</sub>
</td></tr><tr><td>
exp<sub>i</sub> </td><td>  <tt>-&gt;</tt> </td><td>  exp<sub>i+1</sub> [qop<sub>(n,i)</sub> exp<sub>i+1</sub>]
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   lexp<sub>i</sub>
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   rexp<sub>i</sub>
</td></tr><tr><td>
lexp<sub>i</sub> </td><td>  <tt>-&gt;</tt> </td><td>  (lexp<sub>i</sub> | exp<sub>i+1</sub>) qop<sub>(l,i)</sub> exp<sub>i+1</sub>
</td></tr><tr><td>
lexp<sub>6</sub> </td><td>  <tt>-&gt;</tt> </td><td>  <tt>-</tt> exp<sub>7</sub>
</td></tr><tr><td>
rexp<sub>i</sub> </td><td>  <tt>-&gt;</tt> </td><td>  exp<sub>i+1</sub> qop<sub>(r,i)</sub> (rexp<sub>i</sub> | exp<sub>i+1</sub>)
</td></tr><tr><td>
exp<sub>10</sub> </td><td>  <tt>-&gt;</tt> </td><td>  <tt>\</tt> apat<sub>1</sub> ... apat<sub>n</sub> <tt>-&gt;</tt> exp	</td><td> (lambda abstraction, n&gt;=1)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   <tt>let</tt> decllist <tt>in</tt> exp	        </td><td> (let expression)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   <tt>if</tt> exp <tt>then</tt> exp <tt>else</tt> exp	</td><td> (conditional)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   <tt>case</tt> exp <tt>of</tt> <tt>{</tt> alts [<tt>;</tt>] <tt>}</tt>	</td><td> (case expression)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   <tt>do</tt> <tt>{</tt> stmts [<tt>;</tt>] <tt>}</tt>            </td><td> (do expression)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   fexp
</td></tr><tr><td>
fexp </td><td>  <tt>-&gt;</tt> </td><td>  [fexp] aexp				</td><td> (function application)
</td></tr></table>
<p>
<table cellspacing=0 cellspacing=0>
<tr><td width=100>
aexp </td><td width=20>  <tt>-&gt;</tt> </td><td width=250>  qvar				</td><td> (variable)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   gcon				</td><td> (general constructor)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   literal				
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   <tt>(</tt> exp <tt>)</tt>			      </td><td> (parenthesized expression)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   <tt>(</tt> exp<sub>1</sub> <tt>,</tt> ... <tt>,</tt> exp<sub>k</sub> <tt>)</tt>	</td><td> (tuple, k&gt;=2)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   <tt>[</tt> exp<sub>1</sub> <tt>,</tt> ... <tt>,</tt> exp<sub>k</sub> <tt>]</tt>	</td><td> (list, k&gt;=1)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   <tt>[</tt> exp<sub>1</sub> [<tt>,</tt> exp<sub>2</sub>] <tt>..</tt> [exp<sub>3</sub>] <tt>]</tt> </td><td> (arithmetic sequence)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   <tt>[</tt> exp <tt>|</tt> qual<sub>1</sub> <tt>,</tt> ... <tt>,</tt> qual<sub>n</sub> <tt>]</tt>	</td><td> (list comprehension, n&gt;=1)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   <tt>(</tt> exp<sub>i+1</sub> qop<sub>(a,i)</sub> <tt>)</tt>        </td><td> (left section)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   <tt>(</tt> qop<sub>(a,i)</sub> exp<sub>i+1</sub> <tt>)</tt>        </td><td> (right section)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   qcon <tt>{</tt> fbind<sub>1</sub> <tt>,</tt> ... <tt>,</tt> fbind<sub>n</sub> <tt>}</tt> </td><td> (labeled construction, n&gt;=0)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   aexp<sub>{qcon}</sub> <tt>{</tt> fbind<sub>1</sub> <tt>,</tt> ... <tt>,</tt> fbind<sub>n</sub> <tt>}</tt> </td><td> (labeled update, n &gt;= 1)
</td></tr></table>
<p>
<table cellspacing=0 cellspacing=0>
<tr><td width=100></td><td width=20></td><td width=250></td></tr><tr></tr><tr></tr><tr></tr><tr><td>
qual </td><td>  <tt>-&gt;</tt> </td><td> pat <tt>&lt;-</tt> exp 
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>let</tt> decllist
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  exp 
</td></tr><tr><td>
alts </td><td>  <tt>-&gt;</tt> </td><td>  alt<sub>1</sub> <tt>;</tt> ... <tt>;</tt> alt<sub>n</sub> 		</td><td> (n&gt;=1)
</td></tr><tr><td>
alt </td><td>  <tt>-&gt;</tt> </td><td>  pat <tt>-&gt;</tt> exp [<tt>where</tt> decllist]
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   pat gdpat [<tt>where</tt> decllist]
</td></tr><tr><td>
gdpat </td><td>  <tt>-&gt;</tt> </td><td>  gd <tt>-&gt;</tt> exp [ gdpat ]
</td></tr><tr><td>
stmts </td><td>  <tt>-&gt;</tt> </td><td> exp [<tt>;</tt> stmts]
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td> pat <tt>&lt;-</tt> exp <tt>;</tt> stmts
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td> <tt>let</tt> decllist <tt>;</tt> stmts
</td></tr><tr><td>
fbinds </td><td>  <tt>-&gt;</tt> </td><td>  <tt>{</tt> fbind<sub>1</sub> <tt>,</tt> ... <tt>,</tt> fbind<sub>n</sub> <tt>}</tt>    </td><td> (n&gt;=0)
</td></tr><tr><td>
fbind </td><td>  <tt>-&gt;</tt> </td><td>  var | qvar <tt>=</tt> exp
</td></tr><tr><td>
 </td><td> 
</td></tr></table>
<p>
<table cellspacing=0 cellspacing=0>
<tr><td width=100>
pat </td><td width=20>  <tt>-&gt;</tt> </td><td width=250>  var <tt>+</tt> integer </td><td> (successor pattern)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  pat<sub>0</sub>
</td></tr><tr><td>
pat<sub>i</sub> </td><td>  <tt>-&gt;</tt> </td><td>  pat<sub>i+1</sub> [qconop<sub>(n,i)</sub> pat<sub>i+1</sub>]
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   lpat<sub>i</sub>
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   rpat<sub>i</sub>
</td></tr><tr><td>
lpat<sub>i</sub> </td><td>  <tt>-&gt;</tt> </td><td>  (lpat<sub>i</sub> | pat<sub>i+1</sub>) qconop<sub>(l,i)</sub> pat<sub>i+1</sub>
</td></tr><tr><td>
lpat<sub>6</sub> </td><td>  <tt>-&gt;</tt> </td><td>  <tt>-</tt> (integer | float)		</td><td> (negative literal)
</td></tr><tr><td>
rpat<sub>i</sub> </td><td>  <tt>-&gt;</tt> </td><td>  pat<sub>i+1</sub> qconop<sub>(r,i)</sub> (rpat<sub>i</sub> | pat<sub>i+1</sub>)
</td></tr><tr><td>
pat<sub>10</sub>-&gt; </td><td> apat
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   gcon apat<sub>1</sub> ... apat<sub>k</sub>		</td><td> (arity gcon = k, k&gt;=1)
</td></tr></table>
<p>
<table cellspacing=0 cellspacing=0>
<tr><td width=100></td><td width=20></td><td width=250></td></tr><tr><td>
apat </td><td>  <tt>-&gt;</tt> </td><td>  var [<tt>@</tt> apat]			</td><td> (as pattern)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   gcon				</td><td> (arity gcon = 0) 
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   qcon <tt>{</tt> fpat<sub>1</sub> <tt>,</tt> ... <tt>,</tt> fpat<sub>k</sub> <tt>}</tt> </td><td> (labeled pattern, k&gt;=0)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   literal
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   <tt>_</tt>					</td><td> (wildcard)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   <tt>(</tt> pat <tt>)</tt>				</td><td> (parenthesized pattern)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   <tt>(</tt> pat<sub>1</sub> <tt>,</tt> ... <tt>,</tt> pat<sub>k</sub> <tt>)</tt>	</td><td> (tuple pattern, k&gt;=2)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   <tt>[</tt> pat<sub>1</sub> <tt>,</tt> ... <tt>,</tt> pat<sub>k</sub> <tt>]</tt>	</td><td> (list pattern, k&gt;=1) 
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   <tt>~</tt> apat				</td><td> (irrefutable pattern)
</td></tr><tr><td>
fpat </td><td>  <tt>-&gt;</tt> </td><td>  var <tt>=</tt> pat
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   var
</td></tr></table>
<p>
<table cellspacing=0 cellspacing=0>
<tr><td width=100></td><td width=20></td><td width=250></td></tr><tr><td>
gcon </td><td>  <tt>-&gt;</tt> </td><td>  <tt>()
</tt></td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   <tt>[]
</tt></td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   <tt>(,</tt>{<tt>,</tt>}<tt>)
</tt></td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   qcon
</td></tr><tr><td>
var </td><td>  <tt>-&gt;</tt> </td><td>  varid | <tt>(</tt> varsym <tt>)</tt>		</td><td> (variable)
</td></tr><tr><td>
qvar </td><td>  <tt>-&gt;</tt> </td><td>  qvarid | <tt>(</tt> qvarsym <tt>)</tt>		</td><td> (qualified variable)
</td></tr><tr><td>
con </td><td>  <tt>-&gt;</tt> </td><td>  conid | <tt>(</tt> consym <tt>)</tt>		</td><td> (constructor)
</td></tr><tr><td>
qcon </td><td>  <tt>-&gt;</tt> </td><td>  qconid | <tt>(</tt> qconsym <tt>)</tt>		</td><td> (qualified constructor)
</td></tr><tr><td>
varop </td><td>  <tt>-&gt;</tt> </td><td>  varsym | `varid`</td><td> (variable operator)
</td></tr><tr><td>
qvarop </td><td>  <tt>-&gt;</tt> </td><td>  qvarsym | `qvarid`</td><td> (qualified variable operator)
</td></tr><tr><td>
conop </td><td>  <tt>-&gt;</tt> </td><td>  consym | `conid`</td><td> (constructor operator)
</td></tr><tr><td>
qconop </td><td>  <tt>-&gt;</tt> </td><td>  qconsym | `qconid`</td><td> (qualified constructor operator)
</td></tr><tr><td>
op </td><td>  <tt>-&gt;</tt> </td><td>  varop | conop 			</td><td> (operator)
</td></tr><tr><td>
qop </td><td>  <tt>-&gt;</tt> </td><td>  qvarop | qconop			</td><td> (qualified operator)
</td></tr></table>
<p>
<hr><i>The Haskell 1.4 Report</i><br><a href="index.html">top</a> | <a href="standard-prelude.html">back</a> | <a href="literate.html">next</a> | <a href="index14.html">contents</a> | <a href="prelude-index.html">function index</a> <br><font size=2>March 27, 1997</font>
<p>
