
<title>Haskell 98 Lexical Structure</title>
<body bgcolor="#ffffff"> <i>The Haskell 98 Report</i><br> <a href="index.html">top</a> | <a href="intro.html">back</a> | <a href="exps.html">next</a> | <a href="index98.html">contents</a> | <a href="prelude-index.html">function index</a> <br><hr>
<a name="lexical-structure"></a><a name="sect2"></a>
<h2>2<tt>&nbsp;&nbsp;</tt>Lexical Structure</h2>
<p>

In this section, 
we describe the low-level lexical structure of Haskell .
Most of the details may be skipped in a first reading of
the report.<a name="notational-conventions"></a><p>
<a name="sect2.1"></a>
<h3>2.1<tt>&nbsp;&nbsp;</tt>Notational Conventions</h3>
<p>
These notational conventions are used for presenting syntax:<p>
<p>
<table >
<tr><td align=center>
<I>[pattern]</I>		</td><td> optional </td></tr><tr><td align=center><I>{pattern}</I>		</td><td> zero or more repetitions </td></tr><tr><td align=center><I>(pattern)</I>		</td><td> grouping </td></tr><tr><td align=center><I>pat</I><sub><I>1</I></sub><I> | pat</I><sub><I>2</I></sub>		</td><td> choice </td></tr><tr><td align=center><I>pat</I><sub><I>&lt;pat'&gt;</I></sub>	</td><td> difference---elements generated by <I>pat</I> </td></tr><tr><td align=center></td><td> except those generated by <I>pat'</I> </td></tr><tr><td align=center><tt>fibonacci</tt>		</td><td> terminal syntax in typewriter font
</td></tr></table>
<p>
<p>
Because the syntax in this section describes <I>lexical</I> syntax, all
whitespace is expressed explicitly; there is no
implicit space between juxtaposed symbols.  BNF-like syntax is used
throughout, with productions having the form:
<table cellspacing=0 cellspacing=0>
<tr><td width=100>
nonterm </td><td width=20>  <tt>-&gt;</tt> </td><td width=250> alt<sub>1</sub> | alt<sub>2</sub> | ... | alt<sub>n</sub>
</td></tr></table>
<p>
Care must be taken in distinguishing metalogical syntax such as <I>|
</I>and <I>[...]</I> from concrete terminal syntax (given in typewriter font)
such as <tt>|</tt> and <tt>[...]</tt>, although usually the context makes the
distinction clear.<p>
Haskell  uses the Unicode [<a href="haskell.html#$unicode">10</a>] character set.

However, source 
programs are currently biased toward the ASCII character set
 used in earlier versions of Haskell .<p>
Haskell uses a pre-processor to convert non-Unicode character sets into
Unicode.  This pre-processor converts all characters to Unicode and
uses the escape sequence <tt>\u</tt><I>hhhh</I>, where the <tt>"h"</tt> are hex digits,
to denote escaped Unicode characters.  Since this translation occurs
before the program is compiled, escaped Unicode characters may appear in
identifiers and any other place in the program.<p>
This syntax depends on properties of the Unicode characters as defined
by the Unicode consortium. 
Haskell  compilers are expected to make use of
new versions of Unicode as they are made available.<a name="lexemes"></a><p>
<a name="sect2.2"></a>
<h3>2.2<tt>&nbsp;&nbsp;</tt>Lexical Program Structure</h3>
<a name="whitespace"></a>
<p>
<table cellspacing=0 cellspacing=0>
<tr><td width=100></td><td width=20></td><td width=250></td></tr><tr></tr><tr></tr><tr></tr><tr><td>
program </td><td>  <tt>-&gt;</tt> </td><td> {lexeme | whitespace }
</td></tr><tr><td>
lexeme </td><td>  <tt>-&gt;</tt> </td><td> varid | conid | varsym | consym | literal | special | reservedop | reservedid
</td></tr><tr><td>
literal </td><td>  <tt>-&gt;</tt> </td><td> integer | float | char | string
</td></tr><tr><td>
special </td><td>  <tt>-&gt;</tt> </td><td> <tt>(</tt> | <tt>)</tt> | <tt>,</tt> | <tt>;</tt> | <tt>[</tt> | <tt>]</tt> | `| <tt>{</tt> | <tt>}
</tt></td></tr><tr><td>
whitespace </td><td>  <tt>-&gt;</tt> </td><td> whitestuff {whitestuff}
</td></tr><tr><td>
whitestuff </td><td>  <tt>-&gt;</tt> </td><td> whitechar | comment | ncomment
</td></tr><tr><td>
whitechar </td><td>  <tt>-&gt;</tt> </td><td> newline | return | linefeed | vertab | formfeed
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td> space | tab | uniWhite
</td></tr><tr><td>
newline </td><td>  <tt>-&gt;</tt> </td><td> a newline (system dependent)
</td></tr><tr><td>
return </td><td>  <tt>-&gt;</tt> </td><td> a carriage return
</td></tr><tr><td>
linefeed </td><td>  <tt>-&gt;</tt> </td><td> a line feed
</td></tr><tr><td>
vertab </td><td>  <tt>-&gt;</tt> </td><td> a vertical tab
</td></tr><tr><td>
formfeed </td><td>  <tt>-&gt;</tt> </td><td> a form feed
</td></tr><tr><td>
space </td><td>  <tt>-&gt;</tt> </td><td> a space
</td></tr><tr><td>
tab </td><td>  <tt>-&gt;</tt> </td><td> a horizontal tab
</td></tr><tr><td>
uniWhite </td><td>  <tt>-&gt;</tt> </td><td> any UNIcode character defined as whitespace
</td></tr><tr><td>
comment </td><td>  <tt>-&gt;</tt> </td><td> dashes {any}newline
</td></tr><tr><td>
dashes </td><td>  <tt>-&gt;</tt> </td><td> <tt>--</tt> {<tt>-</tt>}
</td></tr><tr><td>
opencom </td><td>  <tt>-&gt;</tt> </td><td> <tt>{-
</tt></td></tr><tr><td>
closecom </td><td>  <tt>-&gt;</tt> </td><td> <tt>-}
</tt></td></tr><tr><td>
ncomment </td><td>  <tt>-&gt;</tt> </td><td> opencom ANYseq {ncomment ANYseq}closecom
</td></tr><tr><td>
ANYseq </td><td>  <tt>-&gt;</tt> </td><td> {ANY}<sub>&lt;{ANY}( opencom | closecom ) {ANY}&gt;</sub>
</td></tr><tr><td>
ANY </td><td>  <tt>-&gt;</tt> </td><td> any | newline | vertab | formfeed
</td></tr><tr><td>
any </td><td>  <tt>-&gt;</tt> </td><td> graphic | space | tab
</td></tr><tr><td>
graphic </td><td>  <tt>-&gt;</tt> </td><td> small | large | symbol | digit | special | <tt>:</tt> | <tt>"</tt> | <tt>'
</tt></td></tr><tr><td>
small </td><td>  <tt>-&gt;</tt> </td><td> ascSmall | uniSmall | <tt>_
</tt></td></tr><tr><td>
ascSmall </td><td>  <tt>-&gt;</tt> </td><td> <tt>a</tt> | <tt>b</tt> | ... | <tt>z
</tt></td></tr><tr><td>
uniSmall </td><td>  <tt>-&gt;</tt> </td><td> any Unicode lowercase letter
</td></tr><tr><td>
large </td><td>  <tt>-&gt;</tt> </td><td> ascLarge | uniLarge
</td></tr><tr><td>
ascLarge </td><td>  <tt>-&gt;</tt> </td><td> <tt>A</tt> | <tt>B</tt> | ... | <tt>Z
</tt></td></tr><tr><td>
uniLarge </td><td>  <tt>-&gt;</tt> </td><td> any uppercase or titlecase Unicode letter
</td></tr><tr><td>
symbol </td><td>  <tt>-&gt;</tt> </td><td> ascSymbol | uniSymbol
</td></tr><tr><td>
ascSymbol </td><td>  <tt>-&gt;</tt> </td><td> <tt>!</tt> | <tt>#</tt> | <tt>$</tt> | <tt>%</tt> | <tt>&amp;</tt> | <tt>*</tt> | <tt>+</tt> | <tt>.</tt> | <tt>/</tt> | <tt>&lt;</tt> | <tt>=</tt> | <tt>&gt;</tt> | <tt>?</tt> | @
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>\</tt> | <tt>^</tt> | <tt>|</tt> | <tt>-</tt> | <tt>~
</tt></td></tr><tr><td>
uniSymbol </td><td>  <tt>-&gt;</tt> </td><td> any Unicode symbol or punctuation
</td></tr><tr><td>
digit </td><td>  <tt>-&gt;</tt> </td><td> ascDigit | uniDigit
</td></tr><tr><td>
ascDigit </td><td>  <tt>-&gt;</tt> </td><td> <tt>0</tt> | <tt>1</tt> | ... | <tt>9
</tt></td></tr><tr><td>
uniDigit </td><td>  <tt>-&gt;</tt> </td><td> any Unicode numeric
</td></tr><tr><td>
octit </td><td>  <tt>-&gt;</tt> </td><td> <tt>0</tt> | <tt>1</tt> | ... | <tt>7
</tt></td></tr><tr><td>
hexit </td><td>  <tt>-&gt;</tt> </td><td> digit | <tt>A</tt> | ... | <tt>F</tt> | <tt>a</tt> | ... | <tt>f
</tt></td></tr></table>
<p>
Lexical analysis should use the "maximal munch" rule.
At each point, the longest possible lexeme
satisfying the <I>lexeme</I> production is read, 

using a context-independent deterministic lexical analysis
(i.e. no lookahead beyond the current character is required).
So, although <tt>case</tt> is a reserved word, <tt>cases</tt> is not.
Similarly, although <tt>=</tt> is reserved, <tt>==</tt> and <tt>~=</tt> are
not.  <p>
Any kind of <I>whitespace</I> is also a proper delimiter for lexemes.<p>
Characters not in the category <I>ANY</I> are not valid
in Haskell  programs and should result in a lexing error.<p>
<a name="sect2.3"></a>
<h3>2.3<tt>&nbsp;&nbsp;</tt>Comments</h3><p>
Comments are valid whitespace.<p>
An ordinary
comment begins with a lexeme consisting of
two or more consecutive dashes (e.g. <tt>--</tt>) and extends to the following newline.
The comment must begin with a lexeme consisting entirely of dashes, <I>parsed according
to the maximal-munch rule</I>.  For example, "<tt>--&gt;</tt>" or "<tt>--|</tt>" do <I>not</I> begin
a comment, because the lexeme does not consist entirely of dashes.<p>
A nested comment begins with the lexeme "<tt>{-</tt>" 
and ends with the string "<tt>-}</tt>".  As in the case of
ordinary comments, the maximal munch rule applies, but the longest
legal lexeme starting with "<tt>{-</tt>" is "<tt>{-</tt>"; hence the string
"<tt>{---</tt>", for example, has "<tt>{-</tt>" as its initial lexeme, and 
does indeed start a nested comment.<p>
The comment itself is not lexically analysed.  Instead the first
unmatched occurrence of the string "<tt>-}</tt>" terminates the nested comment.
Nested comments may be
nested to any depth: any occurrence of the string "<tt>{-</tt>" within the nested
comment starts a new nested comment, terminated by "<tt>-}</tt>".  Within
a nested comment, each "<tt>{-</tt>" is matched by a corresponding
occurrence of "<tt>-}</tt>".<p>
In an ordinary comment, the character
sequences "<tt>{-</tt>" and "<tt>-}</tt>" have no special significance, and, in a
nested comment, a sequence of dashes has no special significance.<p>
Nested comments are also used for compiler pragmas, as explained in
Appendix <a href="pragmas.html#pragmas">E</a>.<p>
If some code is commented out using a nested comment, then any
occurrence of <tt>{-</tt> or <tt>-}</tt> within a string or within an end-of-line
comment in that code will interfere with the nested comments.<a name="ids"></a><p>
<a name="sect2.4"></a>
<h3>2.4<tt>&nbsp;&nbsp;</tt>Identifiers and Operators</h3>
<p>
<table cellspacing=0 cellspacing=0>
<tr><td width=100></td><td width=20></td><td width=250></td></tr><tr><td>
varid </td><td>  <tt>-&gt;</tt> </td><td> (small {small | large | digit | <tt>'</tt> })<sub>&lt;reservedid&gt;</sub>
</td></tr><tr><td>
conid </td><td>  <tt>-&gt;</tt> </td><td> large {small | large | digit | <tt>'</tt> }
</td></tr><tr><td>
reservedid </td><td>  <tt>-&gt;</tt> </td><td> <tt>case</tt> | <tt>class</tt> | <tt>data</tt> | <tt>default</tt> | <tt>deriving</tt> | <tt>do</tt> | <tt>else
</tt></td></tr><tr><td>
</td><td> <tt>|</tt> </td><td> <tt>if</tt> | <tt>import</tt> | <tt>in</tt> | <tt>infix</tt> | <tt>infixl</tt> | <tt>infixr</tt> | <tt>instance
</tt></td></tr><tr><td>
</td><td> <tt>|</tt> </td><td> <tt>let</tt> | <tt>module</tt> | <tt>newtype</tt> | <tt>of</tt> | <tt>then</tt> | <tt>type</tt> | <tt>where</tt> | <tt>_
</tt></td></tr><tr><td>
specialid </td><td>  <tt>-&gt;</tt> </td><td> <tt>as</tt> | <tt>qualified</tt> | <tt>hiding
</tt></td></tr></table>
<p>
An identifier consists of a letter followed by zero or more letters,
digits, underscores, and single quotes.  Identifiers are lexically
distinguished into two classes: those that begin with a lower-case letter
(variable identifiers) and those that begin with an upper-case letter
(constructor identifiers).  Identifiers are case sensitive: <tt>name</tt>,
<tt>naMe</tt>, and <tt>Name</tt> are three distinct identifiers (the first two are
variable identifiers, the last is a constructor identifier).<p>
Underscore, "<tt>_</tt>", is treated as a lower-case letter, and can occur
wherever a lower-case letter can.  However, "<tt>_</tt>" all by itself is a
reserved identifier, used as wild card in patterns.  Compilers that offer
warnings for unused identifiers are encouraged to suppress such warnings for
identifiers beginning with underscore.  This allows programmers to use
"<tt>_foo</tt>" for a parameter that they expect to be unused.<p>
<table cellspacing=0 cellspacing=0>
<tr><td width=100>
varsym </td><td width=20>  <tt>-&gt;</tt> </td><td width=250> ( symbol {symbol | <tt>:</tt>})<sub>&lt;reservedop&gt;</sub>
</td></tr><tr><td>
consym </td><td>  <tt>-&gt;</tt> </td><td> (<tt>:</tt> {symbol | <tt>:</tt>})<sub>&lt;reservedop&gt;</sub>
</td></tr><tr><td>
reservedop </td><td>  <tt>-&gt;</tt> </td><td> <tt>..</tt> | <tt>:</tt> | <tt>::</tt> | <tt>=</tt> | <tt>\</tt> | <tt>|</tt> | <tt>&lt;-</tt> | <tt>-&gt;</tt> | <tt>@</tt> | <tt>~</tt> | <tt>=&gt;
</tt></td></tr><tr><td>
specialop </td><td>  <tt>-&gt;</tt> </td><td> <tt>-</tt> | <tt>!
</tt></td></tr></table>
<p>
Operator symbols are formed from one or more symbol characters, as
defined above, and are lexically distinguished into two classes: those
that start with a colon (constructors) and those that do not (functions).
Notice that a colon by itself, "<tt>:</tt>", is reserved solely for use
as the Haskell list constructor; this makes its treatment uniform with
other parts of list syntax, such as "<tt>[]</tt>" and "<tt>[a,b]</tt>".<p>
Other than the special syntax for prefix negation, all operators are
infix, although each infix operator can be used in a 
<I>section</I> to yield partially applied operators (see
Section <a href="exps.html#sections">3.5</a>).
All of the standard infix operators are just
predefined symbols and may be rebound.  <p>
A few identifiers and operators, here indicated by <I>specialid</I> and <I>specialop</I>,
have special meanings in certain contexts, but can be used as ordinary
identifiers and operators.
These are indicated by the `special' productions in the lexical syntax.
Examples include <tt>!</tt> (used only in <tt>data</tt> declarations) and
<tt>hiding</tt> (used in <tt>import</tt> declarations).<p>
In the remainder of the report six different kinds of 
names will be used:<p>
<table cellspacing=0 cellspacing=0>
<tr><td width=100>
varid </td><td width=20> </td><td width=250></td><td> (variables)
</td></tr><tr><td>
conid </td><td> </td><td></td><td> (constructors)
</td></tr><tr><td>
tyvar </td><td>  <tt>-&gt;</tt> </td><td>  varid	</td><td> (type variables)
</td></tr><tr><td>
tycon </td><td>  <tt>-&gt;</tt> </td><td>  conid 	</td><td> (type constructors)
</td></tr><tr><td>
tycls </td><td>  <tt>-&gt;</tt> </td><td>  conid 	</td><td> (type classes)
</td></tr><tr><td>
modid </td><td>  <tt>-&gt;</tt> </td><td>  conid	</td><td> (modules)
</td></tr></table>
<p>
Variables and type variables are represented by identifiers beginning
with small letters, and the other four by identifiers beginning with
capitals; also, variables and constructors have infix forms, the other
four do not.  Namespaces are also discussed in
Section <a href="intro.html#namespaces">1.4</a>.<p>

External names may optionally be <I>qualified</I> in certain
circumstances by prepending them with a module identifier.  This
applies to variable, constructor, type constructor and type class
names, but not type variables or module names.  Qualified
names are discussed in detail in Section <a href="modules.html#import">5.3</a>.
<table cellspacing=0 cellspacing=0>
<tr><td width=100>
qvarid </td><td width=20>  <tt>-&gt;</tt> </td><td width=250> [modid <tt>.</tt>] varid
</td></tr><tr><td>
qconid </td><td>  <tt>-&gt;</tt> </td><td> [modid <tt>.</tt>] conid
</td></tr><tr><td>
qtycon </td><td>  <tt>-&gt;</tt> </td><td> [modid <tt>.</tt>] tycon
</td></tr><tr><td>
qtycls </td><td>  <tt>-&gt;</tt> </td><td> [modid <tt>.</tt>] tycls
</td></tr><tr><td>
qvarsym </td><td>  <tt>-&gt;</tt> </td><td> [modid <tt>.</tt>] varsym
</td></tr><tr><td>
qconsym </td><td>  <tt>-&gt;</tt> </td><td> [modid <tt>.</tt>] consym
</td></tr></table>
<a name="lexemes-numeric"></a><p>
<a name="sect2.5"></a>
<h3>2.5<tt>&nbsp;&nbsp;</tt>Numeric Literals</h3>
<p>
<table cellspacing=0 cellspacing=0>
<tr><td width=100>
decimal </td><td width=20>  <tt>-&gt;</tt> </td><td width=250> digit{digit}
</td></tr><tr><td>
octal </td><td>  <tt>-&gt;</tt> </td><td> octit{octit}
</td></tr><tr><td>
hexadecimal </td><td>  <tt>-&gt;</tt> </td><td> hexit{hexit}
</td></tr></table>
<table cellspacing=0 cellspacing=0>
<tr><td width=100>
integer </td><td width=20>  <tt>-&gt;</tt> </td><td width=250> decimal
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>0o</tt> octal | <tt>0O</tt> octal
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>0x</tt> hexadecimal | <tt>0X</tt> hexadecimal
</td></tr><tr><td>
float </td><td>  <tt>-&gt;</tt> </td><td> decimal <tt>.</tt> decimal[(<tt>e</tt> | <tt>E</tt>)[<tt>-</tt> | <tt>+</tt>]decimal]
</td></tr></table>
There are two distinct kinds of numeric literals: integer and
floating.  Integer literals may be given in decimal (the default),
octal (prefixed by <tt>0o</tt> or <tt>0O</tt>) or hexadecimal notation (prefixed by
<tt>0x</tt> or <tt>0X</tt>).
Floating literals are always decimal.
A floating literal must contain digits both before and after the
decimal point; this ensures that a decimal point cannot be mistaken
for another use of the dot character.  Negative numeric literals are
discussed in Section <a href="exps.html#operators">3.4</a>.  The typing of numeric literals
is discussed in Section <a href="basic.html#numeric-literals">6.4.1</a>.<a name="lexemes-char"></a><p>
<a name="sect2.6"></a>
<h3>2.6<tt>&nbsp;&nbsp;</tt>Character and String Literals</h3>


<p>
<table cellspacing=0 cellspacing=0>
<tr><td width=100>
char </td><td width=20>  <tt>-&gt;</tt> </td><td width=250>  <tt>'</tt> (graphic<sub>&lt;<tt>'</tt> | <tt>\</tt>&gt;</sub> | space | escape<sub>&lt;<tt>\&amp;</tt>&gt;</sub>) <tt>'
</tt></td></tr><tr><td>
string </td><td>  <tt>-&gt;</tt> </td><td>  <tt>"</tt> {graphic<sub>&lt;<tt>"</tt>  | <tt>\</tt>&gt;</sub> | space | escape | gap}<tt>"
</tt></td></tr><tr><td>
escape </td><td>  <tt>-&gt;</tt> </td><td>  <tt>\</tt> ( charesc | ascii | decimal | <tt>o</tt> octal | <tt>x</tt> hexadecimal )
</td></tr><tr><td>
charesc </td><td>  <tt>-&gt;</tt> </td><td> <tt>a</tt> | <tt>b</tt> | <tt>f</tt> | <tt>n</tt> | <tt>r</tt> | <tt>t</tt> | <tt>v</tt> | <tt>\</tt> | <tt>"</tt> | <tt>'</tt> | <tt>&amp;
</tt></td></tr><tr><td>
ascii </td><td>  <tt>-&gt;</tt> </td><td> <tt>^</tt>cntrl | <tt>NUL</tt> | <tt>SOH</tt> | <tt>STX</tt> | <tt>ETX</tt> | <tt>EOT</tt> | <tt>ENQ</tt> | <tt>ACK</tt> 
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td> <tt>BEL</tt> | <tt>BS</tt> | <tt>HT</tt> | <tt>LF</tt> | <tt>VT</tt> | <tt>FF</tt> | <tt>CR</tt> | <tt>SO</tt> | <tt>SI</tt> | <tt>DLE</tt> 
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td> <tt>DC1</tt> | <tt>DC2</tt> | <tt>DC3</tt> | <tt>DC4</tt> | <tt>NAK</tt> | <tt>SYN</tt> | <tt>ETB</tt> | <tt>CAN</tt> 
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td> <tt>EM</tt> | <tt>SUB</tt> | <tt>ESC</tt> | <tt>FS</tt> | <tt>GS</tt> | <tt>RS</tt> | <tt>US</tt> | <tt>SP</tt> | <tt>DEL
</tt></td></tr><tr><td>
cntrl </td><td>  <tt>-&gt;</tt> </td><td> ASClarge | @ | <tt>[</tt> | <tt>\</tt> | <tt>]</tt> | <tt>^</tt> | <tt>_
</tt></td></tr><tr><td>
gap </td><td>  <tt>-&gt;</tt> </td><td>  <tt>\</tt> whitechar {whitechar}<tt>\
</tt></td></tr></table>
<p>
Character literals are written between single quotes, as in
<tt>'a'</tt>, and strings between double quotes, as in <tt>"Hello"</tt>.<p>
Escape codes may be used in characters and strings to represent
special characters.  Note that a single quote <tt>'</tt> may be used in a string, but
must be escaped in a character; similarly, a double quote <tt>"</tt> may be used in a
character, but must be escaped in a string.  <tt>\</tt> must always be
escaped.  The category <I>charesc</I> also includes portable
representations for the characters "alert" (<tt>\a</tt>), "backspace"
(<tt>\b</tt>), "form feed" (<tt>\f</tt>), "new line" (<tt>\n</tt>), "carriage return"
(<tt>\r</tt>), "horizontal tab" (<tt>\t</tt>), and "vertical tab" (<tt>\v</tt>).<p>
Escape characters for the Unicode character
set, including
control characters such as <tt>\^X</tt>, are also provided.
Numeric escapes such as <tt>\137</tt> are used to designate the character
with decimal representation 137; octal
(e.g. <tt>\o137</tt>) and hexadecimal (e.g. <tt>\x37</tt>) representations are also
allowed.  Numeric escapes that are out-of-range of the Unicode standard
(16 bits) are an error.<p>
Consistent with the "maximal munch" rule,

numeric escape
characters in strings consist of all consecutive digits and may
be of arbitrary length.  Similarly, the one ambiguous ASCII escape
code, <tt>"\SOH"</tt>, is parsed as a string of length 1.  The escape
character <tt>\&amp;</tt> is provided as a "null character" to allow strings
such as <tt>"\137\&amp;9"</tt> and <tt>"\SO\&amp;H"</tt> to be constructed (both of length
two).  Thus <tt>"\&amp;"</tt> is equivalent to <tt>""</tt> and the character
<tt>'\&amp;'</tt> is disallowed.  Further equivalences of characters
are defined in Section <a href="basic.html#characters">6.1.2</a>.<p>
A string may include a "gap"---two backslants enclosing
white characters---which is ignored.
This allows one to write long strings on more than one line by writing
a backslant at the end of one line and at the start of the next.  For
example,
<tt><br>

<br>
"Here&nbsp;is&nbsp;a&nbsp;backslant&nbsp;\\&nbsp;as&nbsp;well&nbsp;as&nbsp;\137,&nbsp;\<br>
&nbsp;&nbsp;&nbsp;&nbsp;\a&nbsp;numeric&nbsp;escape&nbsp;character,&nbsp;and&nbsp;\^X,&nbsp;a&nbsp;control&nbsp;character."<br>
<p>
</tt>String literals are actually abbreviations for lists of characters
(see Section <a href="exps.html#lists">3.7</a>).<a name="lexemes-layout"></a><p>
<a name="sect2.7"></a>
<h3>2.7<tt>&nbsp;&nbsp;</tt>Layout</h3>
<p>
Haskell  permits the omission of the braces and semicolons by
using <I>layout</I> to convey the same information.  This allows both
layout-sensitive and layout-insensitive styles of coding, which
can be freely mixed within one program.  Because layout is
not required, Haskell  programs can be straightforwardly
produced by other programs.<p>
The effect of layout on the meaning of a Haskell program
can be completely specified by adding
braces and semicolons in places determined by the layout.  The meaning of
this augmented program is now layout insensitive.<p>
Informally stated, the braces and semicolons are inserted as follows.
The layout (or "off-side") rule takes effect
whenever the open brace is omitted after the keyword <tt>where</tt>, <tt>let</tt>,
<tt>do</tt>, or
<tt>of</tt>.  When this happens, the indentation of the next lexeme (whether
or not on a new line) is remembered and the omitted open brace is
inserted (the whitespace preceding the lexeme may include comments).
For each subsequent line, if it contains only whitespace or is
indented more, then the previous item is continued (nothing is
inserted); if it is indented the same amount, then a new item begins
(a semicolon is inserted); and if it is indented less, then the
layout list ends (a close brace is inserted).  A close brace is
also inserted whenever the syntactic category containing the
layout list ends; that is, if an illegal lexeme is encountered at
a point where a close brace would be legal, a close brace is inserted.
The layout rule matches only those open braces that it has
inserted; an explicit open brace must be matched by
an explicit close brace.  Within these explicit open braces,
<I>no</I> layout processing is performed for constructs outside the
braces, even if a line is 
indented to the left of an earlier implicit open brace.<p>
Section <a href="syntax-iso.html#layout">B.3</a> gives a more precise definition of the layout rules.<p>
Given these rules, a single newline may actually terminate several
layout lists.  Also, these rules permit:
<tt><br>

<br>
f&nbsp;x&nbsp;=&nbsp;let&nbsp;a&nbsp;=&nbsp;1;&nbsp;b&nbsp;=&nbsp;2&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g&nbsp;y&nbsp;=&nbsp;exp2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in&nbsp;exp1<br>

<br>

</tt>making <tt>a</tt>, <tt>b</tt> and <tt>g</tt> all part of the same layout
list.<p>
As an example, Figure <a href="lexemes.html#layout-before">1</a> shows a (somewhat contrived)
module and Figure <a href="lexemes.html#layout-after">2</a> shows the result of applying the
layout rule to it.  Note in particular: (a) the line beginning <tt>}};pop</tt>,
where the termination of the previous line invokes three applications
of the layout rule, corresponding to the depth (3) of the nested
<tt>where</tt> clauses, (b) the close braces in the <tt>where</tt> clause nested
within the tuple and <tt>case</tt> expression, inserted because the end of the
tuple was detected, and (c) the close brace at the very end, inserted
because of the column 0 indentation of the end-of-file token.<p>
<table border=2 cellpadding=3>
<tr><td><div align=center><table border=2 cellpadding=3>
<tr><td>
<tt><br>
module&nbsp;AStack(&nbsp;Stack,&nbsp;push,&nbsp;pop,&nbsp;top,&nbsp;size&nbsp;)&nbsp;where<br>
data&nbsp;Stack&nbsp;a&nbsp;=&nbsp;Empty&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;MkStack&nbsp;a&nbsp;(Stack&nbsp;a)<br>
<br>
push&nbsp;::&nbsp;a&nbsp;-&gt;&nbsp;Stack&nbsp;a&nbsp;-&gt;&nbsp;Stack&nbsp;a<br>
push&nbsp;x&nbsp;s&nbsp;=&nbsp;MkStack&nbsp;x&nbsp;s<br>
<br>
size&nbsp;::&nbsp;Stack&nbsp;a&nbsp;-&gt;&nbsp;Integer<br>
size&nbsp;s&nbsp;=&nbsp;length&nbsp;(stkToLst&nbsp;s)&nbsp;&nbsp;where<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stkToLst&nbsp;&nbsp;Empty&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;[]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stkToLst&nbsp;(MkStack&nbsp;x&nbsp;s)&nbsp;&nbsp;=&nbsp;x:xs&nbsp;where&nbsp;xs&nbsp;=&nbsp;stkToLst&nbsp;s<br>
<br>
pop&nbsp;::&nbsp;Stack&nbsp;a&nbsp;-&gt;&nbsp;(a,&nbsp;Stack&nbsp;a)<br>
pop&nbsp;(MkStack&nbsp;x&nbsp;s)<br>
&nbsp;&nbsp;=&nbsp;(x,&nbsp;case&nbsp;s&nbsp;of&nbsp;r&nbsp;-&gt;&nbsp;i&nbsp;r&nbsp;where&nbsp;i&nbsp;x&nbsp;=&nbsp;x)&nbsp;--&nbsp;(pop&nbsp;Empty)&nbsp;is&nbsp;an&nbsp;error<br>
<br>
top&nbsp;::&nbsp;Stack&nbsp;a&nbsp;-&gt;&nbsp;a<br>
top&nbsp;(MkStack&nbsp;x&nbsp;s)&nbsp;=&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;(top&nbsp;Empty)&nbsp;is&nbsp;an&nbsp;error<br>

</tt></td></tr></table>
</div>
<div align=center> <h4>Figure 1</h4> </div>
<div align=center><h3>A sample program</h3></div><a name="layout-before"></a>

<div align=center><table border=2 cellpadding=3>
<tr><td>
<tt><br>
module&nbsp;AStack(&nbsp;Stack,&nbsp;push,&nbsp;pop,&nbsp;top,&nbsp;size&nbsp;)&nbsp;where<br>
{data&nbsp;Stack&nbsp;a&nbsp;=&nbsp;Empty&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;MkStack&nbsp;a&nbsp;(Stack&nbsp;a)<br>
<br>
;push&nbsp;::&nbsp;a&nbsp;-&gt;&nbsp;Stack&nbsp;a&nbsp;-&gt;&nbsp;Stack&nbsp;a<br>
;push&nbsp;x&nbsp;s&nbsp;=&nbsp;MkStack&nbsp;x&nbsp;s<br>
<br>
;size&nbsp;::&nbsp;Stack&nbsp;a&nbsp;-&gt;&nbsp;Integer<br>
;size&nbsp;s&nbsp;=&nbsp;length&nbsp;(stkToLst&nbsp;s)&nbsp;&nbsp;where<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{stkToLst&nbsp;&nbsp;Empty&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;[]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;stkToLst&nbsp;(MkStack&nbsp;x&nbsp;s)&nbsp;&nbsp;=&nbsp;x:xs&nbsp;where&nbsp;{xs&nbsp;=&nbsp;stkToLst&nbsp;s<br>
<br>
}};pop&nbsp;::&nbsp;Stack&nbsp;a&nbsp;-&gt;&nbsp;(a,&nbsp;Stack&nbsp;a)<br>
;pop&nbsp;(MkStack&nbsp;x&nbsp;s)<br>
&nbsp;&nbsp;=&nbsp;(x,&nbsp;case&nbsp;s&nbsp;of&nbsp;{r&nbsp;-&gt;&nbsp;i&nbsp;r&nbsp;where&nbsp;{i&nbsp;x&nbsp;=&nbsp;x}})&nbsp;--&nbsp;(pop&nbsp;Empty)&nbsp;is&nbsp;an&nbsp;error<br>
<br>
;top&nbsp;::&nbsp;Stack&nbsp;a&nbsp;-&gt;&nbsp;a<br>
;top&nbsp;(MkStack&nbsp;x&nbsp;s)&nbsp;=&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;(top&nbsp;Empty)&nbsp;is&nbsp;an&nbsp;error<br>
}<br>

</tt></td></tr></table>
</div>
<div align=center> <h4>Figure 2</h4> </div>
<div align=center><h3>Sample program with layout expanded</h3></div><a name="layout-after"></a>
<p>
</td></tr></table>
<p>
<hr><i>The Haskell 98 Report</i><br><a href="index.html">top</a> | <a href="intro.html">back</a> | <a href="exps.html">next</a> | <a href="index98.html">contents</a> | <a href="prelude-index.html">function index</a> <br><font size=2>1 February, 1999</font>
<p>
