
<title>Haskell 98 Syntax</title>
<body bgcolor="#ffffff"> <i>The Haskell 98 Report</i><br> <a href="index.html">top</a> | <a href="standard-prelude.html">back</a> | <a href="literate.html">next</a> | <a href="index98.html">contents</a> | <a href="prelude-index.html">function index</a> <br><hr>
<a name="syntax"></a><a name="sect9"></a>
<h2>9<tt>&nbsp;&nbsp;</tt>Syntax Reference</h2>
<p>
<a name="sect9.1"></a>
<h3>9.1<tt>&nbsp;&nbsp;</tt>Notational Conventions</h3><p>
These notational conventions are used for presenting syntax:<p>
<p>
<table >
<tr><td align=center>
<I>[pattern]</I>		</td><td> optional </td></tr><tr><td align=center><I>{pattern}</I>		</td><td> zero or more repetitions </td></tr><tr><td align=center><I>(pattern)</I>		</td><td> grouping </td></tr><tr><td align=center><I>pat</I><sub><I>1</I></sub><I> | pat</I><sub><I>2</I></sub>		</td><td> choice </td></tr><tr><td align=center><I>pat</I><sub><I>&lt;pat'&gt;</I></sub>	</td><td> difference---elements generated by <I>pat</I> </td></tr><tr><td align=center></td><td> except those generated by <I>pat'</I> </td></tr><tr><td align=center><tt>fibonacci</tt>		</td><td> terminal syntax in typewriter font
</td></tr></table>
<p>
<p>
BNF-like syntax is used throughout, with productions having the form:
<table cellspacing=0 cellspacing=0>
<tr><td width=100>
nonterm </td><td width=20>  <tt>-&gt;</tt> </td><td width=250> alt<sub>1</sub> | alt<sub>2</sub> | ... | alt<sub>n</sub>
</td></tr></table>
<p>
There are some families of nonterminals indexed by
precedence levels (written as a superscript).  Similarly, the
nonterminals <I>op</I>, <I>varop</I>, and <I>conop</I> may have a double index:
a letter <I>l</I>, <I>r</I>, or <I>n</I> for left-, right- or nonassociativity and
a precedence level.  A precedence-level variable <I>i</I> ranges from 0 to 9;
an associativity variable <I>a</I> varies over <I>{l, r, n}</I>.
Thus, for example
<table cellspacing=0 cellspacing=0>
<tr><td width=100>
aexp </td><td width=20>  <tt>-&gt;</tt> </td><td width=250>  <tt>(</tt> exp<sup>i+1</sup> qop<sup>(a,i)</sup> <tt>)
</tt></td></tr></table>
actually stands for 30 productions, with 10 substitutions for <I>i
</I>and 3 for <I>a</I>.<p>
In both the lexical and the context-free syntax, there are some
ambiguities that are to be resolved by making grammatical phrases as
long as possible, proceeding from left to right (in shift-reduce
parsing, resolving shift/reduce conflicts by shifting).  In the lexical
syntax, this is the "maximal munch" rule.  In the
context-free syntax, this means that conditionals, let-expressions, and
lambda abstractions extend to the right as far as possible.<p>
<a name="sect9.2"></a>
<h3>9.2<tt>&nbsp;&nbsp;</tt>Lexical Syntax</h3><p>
<table cellspacing=0 cellspacing=0>
<tr><td width=100></td><td width=20></td><td width=250></td></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr><td>
program </td><td>  <tt>-&gt;</tt> </td><td> {lexeme | whitespace }
</td></tr><tr><td>
lexeme </td><td>  <tt>-&gt;</tt> </td><td> qvarid | qconid | qvarsym | qconsym 
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td> literal | special | reservedop | reservedid
</td></tr><tr><td>
literal </td><td>  <tt>-&gt;</tt> </td><td> integer | float | char | string
</td></tr><tr><td>
special </td><td>  <tt>-&gt;</tt> </td><td> <tt>(</tt> | <tt>)</tt> | <tt>,</tt> | <tt>;</tt> | <tt>[</tt> | <tt>]</tt> | `| <tt>{</tt> | <tt>}
</tt></td></tr><tr><td>
whitespace </td><td>  <tt>-&gt;</tt> </td><td> whitestuff {whitestuff}
</td></tr><tr><td>
whitestuff </td><td>  <tt>-&gt;</tt> </td><td> whitechar | comment | ncomment
</td></tr><tr><td>
whitechar </td><td>  <tt>-&gt;</tt> </td><td> newline | vertab | space | tab | uniWhite
</td></tr><tr><td>
newline </td><td>  <tt>-&gt;</tt> </td><td> return linefeed | return | linefeed | formfeed
</td></tr><tr><td>
return </td><td>  <tt>-&gt;</tt> </td><td> a carriage return
</td></tr><tr><td>
linefeed </td><td>  <tt>-&gt;</tt> </td><td> a line feed
</td></tr><tr><td>
vertab </td><td>  <tt>-&gt;</tt> </td><td> a vertical tab
</td></tr><tr><td>
formfeed </td><td>  <tt>-&gt;</tt> </td><td> a form feed
</td></tr><tr><td>
space </td><td>  <tt>-&gt;</tt> </td><td> a space
</td></tr><tr><td>
tab </td><td>  <tt>-&gt;</tt> </td><td> a horizontal tab
</td></tr><tr><td>
uniWhite </td><td>  <tt>-&gt;</tt> </td><td> any Unicode character defined as whitespace
</td></tr><tr><td>
comment </td><td>  <tt>-&gt;</tt> </td><td> dashes [ any<sub>&lt;symbol&gt;</sub>  {any}] newline
</td></tr><tr><td>
dashes </td><td>  <tt>-&gt;</tt> </td><td> <tt>--</tt> {<tt>-</tt>}
</td></tr><tr><td>
opencom </td><td>  <tt>-&gt;</tt> </td><td> <tt>{-
</tt></td></tr><tr><td>
closecom </td><td>  <tt>-&gt;</tt> </td><td> <tt>-}
</tt></td></tr><tr><td>
ncomment </td><td>  <tt>-&gt;</tt> </td><td> opencom ANYseq {ncomment ANYseq}closecom
</td></tr><tr><td>
ANYseq </td><td>  <tt>-&gt;</tt> </td><td> {ANY}<sub>&lt;{ANY}( opencom | closecom ) {ANY}&gt;</sub>
</td></tr><tr><td>
ANY </td><td>  <tt>-&gt;</tt> </td><td> graphic | whitechar
</td></tr><tr><td>
any </td><td>  <tt>-&gt;</tt> </td><td> graphic | space | tab
</td></tr><tr><td>
graphic </td><td>  <tt>-&gt;</tt> </td><td> small | large | symbol | digit | special | <tt>:</tt> | <tt>"</tt> | <tt>'
</tt></td></tr><tr><td>
small </td><td>  <tt>-&gt;</tt> </td><td> ascSmall | uniSmall | <tt>_
</tt></td></tr><tr><td>
ascSmall </td><td>  <tt>-&gt;</tt> </td><td> <tt>a</tt> | <tt>b</tt> | ... | <tt>z
</tt></td></tr><tr><td>
uniSmall </td><td>  <tt>-&gt;</tt> </td><td> any Unicode lowercase letter
</td></tr><tr><td>
large </td><td>  <tt>-&gt;</tt> </td><td> ascLarge | uniLarge
</td></tr><tr><td>
ascLarge </td><td>  <tt>-&gt;</tt> </td><td> <tt>A</tt> | <tt>B</tt> | ... | <tt>Z
</tt></td></tr><tr><td>
uniLarge </td><td>  <tt>-&gt;</tt> </td><td> any uppercase or titlecase Unicode letter
</td></tr><tr><td>
symbol </td><td>  <tt>-&gt;</tt> </td><td> ascSymbol | uniSymbol<sub>&lt;special | <tt>_</tt> | <tt>:</tt> | <tt>"</tt> | <tt>'</tt>&gt;</sub>
</td></tr><tr><td>
ascSymbol </td><td>  <tt>-&gt;</tt> </td><td> <tt>!</tt> | <tt>#</tt> | <tt>$</tt> | <tt>%</tt> | <tt>&amp;</tt> | <tt>*</tt> | <tt>+</tt> | <tt>.</tt> | <tt>/</tt> | <tt>&lt;</tt> | <tt>=</tt> | <tt>&gt;</tt> | <tt>?</tt> | @
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>\</tt> | <tt>^</tt> | <tt>|</tt> | <tt>-</tt> | <tt>~
</tt></td></tr><tr><td>
uniSymbol </td><td>  <tt>-&gt;</tt> </td><td> any Unicode symbol or punctuation
</td></tr><tr><td>
digit </td><td>  <tt>-&gt;</tt> </td><td> ascDigit | uniDigit
</td></tr><tr><td>
ascDigit </td><td>  <tt>-&gt;</tt> </td><td> <tt>0</tt> | <tt>1</tt> | ... | <tt>9
</tt></td></tr><tr><td>
uniDigit </td><td>  <tt>-&gt;</tt> </td><td> any Unicode decimal digit
</td></tr><tr><td>
octit </td><td>  <tt>-&gt;</tt> </td><td> <tt>0</tt> | <tt>1</tt> | ... | <tt>7
</tt></td></tr><tr><td>
hexit </td><td>  <tt>-&gt;</tt> </td><td> digit | <tt>A</tt> | ... | <tt>F</tt> | <tt>a</tt> | ... | <tt>f
</tt></td></tr></table>
<p>
<table cellspacing=0 cellspacing=0>
<tr><td width=100></td><td width=20></td><td width=250></td></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr><td>
varid </td><td>  <tt>-&gt;</tt> </td><td> (small {small | large | digit | <tt>'</tt> })<sub>&lt;reservedid&gt;</sub>
</td></tr><tr><td>
conid </td><td>  <tt>-&gt;</tt> </td><td> large {small | large | digit | <tt>'</tt> }
</td></tr><tr><td>
reservedid </td><td>  <tt>-&gt;</tt> </td><td> <tt>case</tt> | <tt>class</tt> | <tt>data</tt> | <tt>default</tt> | <tt>deriving</tt> | <tt>do</tt> | <tt>else
</tt></td></tr><tr><td>
</td><td> <tt>|</tt> </td><td> <tt>if</tt> | <tt>import</tt> | <tt>in</tt> | <tt>infix</tt> | <tt>infixl</tt> | <tt>infixr</tt> | <tt>instance
</tt></td></tr><tr><td>
</td><td> <tt>|</tt> </td><td> <tt>let</tt> | <tt>module</tt> | <tt>newtype</tt> | <tt>of</tt> | <tt>then</tt> | <tt>type</tt> | <tt>where</tt> | <tt>_
</tt></td></tr><tr><td>
varsym </td><td>  <tt>-&gt;</tt> </td><td> ( symbol {symbol | <tt>:</tt>})<sub>&lt;reservedop | dashes&gt;</sub>
</td></tr><tr><td>
consym </td><td>  <tt>-&gt;</tt> </td><td> (<tt>:</tt> {symbol | <tt>:</tt>})<sub>&lt;reservedop&gt;</sub>
</td></tr><tr><td>
reservedop </td><td>  <tt>-&gt;</tt> </td><td> <tt>..</tt> | <tt>:</tt> | <tt>::</tt> | <tt>=</tt> | <tt>\</tt> | <tt>|</tt> | <tt>&lt;-</tt> | <tt>-&gt;</tt> | <tt>@</tt> | <tt>~</tt> | <tt>=&gt;
</tt></td></tr><tr><td>
varid </td><td> </td><td></td><td> (variables)
</td></tr><tr><td>
conid </td><td> </td><td></td><td> (constructors)
</td></tr><tr><td>
tyvar </td><td>  <tt>-&gt;</tt> </td><td>  varid	</td><td> (type variables)
</td></tr><tr><td>
tycon </td><td>  <tt>-&gt;</tt> </td><td>  conid 	</td><td> (type constructors)
</td></tr><tr><td>
tycls </td><td>  <tt>-&gt;</tt> </td><td>  conid 	</td><td> (type classes)
</td></tr><tr><td>
modid </td><td>  <tt>-&gt;</tt> </td><td>  conid	</td><td> (modules)
</td></tr><tr><td>
qvarid </td><td>  <tt>-&gt;</tt> </td><td> [ modid <tt>.</tt> ] varid
</td></tr><tr><td>
qconid </td><td>  <tt>-&gt;</tt> </td><td> [ modid <tt>.</tt> ] conid
</td></tr><tr><td>
qtycon </td><td>  <tt>-&gt;</tt> </td><td> [ modid <tt>.</tt> ] tycon
</td></tr><tr><td>
qtycls </td><td>  <tt>-&gt;</tt> </td><td> [ modid <tt>.</tt> ] tycls
</td></tr><tr><td>
qvarsym </td><td>  <tt>-&gt;</tt> </td><td> [ modid <tt>.</tt> ] varsym
</td></tr><tr><td>
qconsym </td><td>  <tt>-&gt;</tt> </td><td> [ modid <tt>.</tt> ] consym
</td></tr><tr><td>
decimal </td><td>  <tt>-&gt;</tt> </td><td> digit{digit}
</td></tr><tr><td>
octal </td><td>  <tt>-&gt;</tt> </td><td> octit{octit}
</td></tr><tr><td>
hexadecimal </td><td>  <tt>-&gt;</tt> </td><td> hexit{hexit}
</td></tr><tr><td>
integer </td><td>  <tt>-&gt;</tt> </td><td> decimal
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>0o</tt> octal | <tt>0O</tt> octal
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>0x</tt> hexadecimal | <tt>0X</tt> hexadecimal
</td></tr><tr><td>
float </td><td>  <tt>-&gt;</tt> </td><td> decimal <tt>.</tt> decimal [exponent]
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  decimal exponent
</td></tr><tr><td>
exponent </td><td>  <tt>-&gt;</tt> </td><td> (<tt>e</tt> | <tt>E</tt>) [<tt>+</tt> | <tt>-</tt>] decimal
</td></tr><tr><td>
char </td><td>  <tt>-&gt;</tt> </td><td>  <tt>'</tt> (graphic<sub>&lt;<tt>'</tt> | <tt>\</tt>&gt;</sub> | space | escape<sub>&lt;<tt>\&amp;</tt>&gt;</sub>) <tt>'
</tt></td></tr><tr><td>
string </td><td>  <tt>-&gt;</tt> </td><td>  <tt>"</tt> {graphic<sub>&lt;<tt>"</tt>  | <tt>\</tt>&gt;</sub> | space | escape | gap}<tt>"
</tt></td></tr><tr><td>
escape </td><td>  <tt>-&gt;</tt> </td><td>  <tt>\</tt> ( charesc | ascii | decimal | <tt>o</tt> octal | <tt>x</tt> hexadecimal )
</td></tr><tr><td>
charesc </td><td>  <tt>-&gt;</tt> </td><td> <tt>a</tt> | <tt>b</tt> | <tt>f</tt> | <tt>n</tt> | <tt>r</tt> | <tt>t</tt> | <tt>v</tt> | <tt>\</tt> | <tt>"</tt> | <tt>'</tt> | <tt>&amp;
</tt></td></tr><tr><td>
ascii </td><td>  <tt>-&gt;</tt> </td><td> <tt>^</tt>cntrl | <tt>NUL</tt> | <tt>SOH</tt> | <tt>STX</tt> | <tt>ETX</tt> | <tt>EOT</tt> | <tt>ENQ</tt> | <tt>ACK</tt> 
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td> <tt>BEL</tt> | <tt>BS</tt> | <tt>HT</tt> | <tt>LF</tt> | <tt>VT</tt> | <tt>FF</tt> | <tt>CR</tt> | <tt>SO</tt> | <tt>SI</tt> | <tt>DLE</tt> 
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td> <tt>DC1</tt> | <tt>DC2</tt> | <tt>DC3</tt> | <tt>DC4</tt> | <tt>NAK</tt> | <tt>SYN</tt> | <tt>ETB</tt> | <tt>CAN</tt> 
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td> <tt>EM</tt> | <tt>SUB</tt> | <tt>ESC</tt> | <tt>FS</tt> | <tt>GS</tt> | <tt>RS</tt> | <tt>US</tt> | <tt>SP</tt> | <tt>DEL
</tt></td></tr><tr><td>
cntrl </td><td>  <tt>-&gt;</tt> </td><td> ascLarge | @ | <tt>[</tt> | <tt>\</tt> | <tt>]</tt> | <tt>^</tt> | <tt>_
</tt></td></tr><tr><td>
gap </td><td>  <tt>-&gt;</tt> </td><td>  <tt>\</tt> whitechar {whitechar}<tt>\
</tt></td></tr></table>
<a name="layout"></a><p>
<a name="sect9.3"></a>
<h3>9.3<tt>&nbsp;&nbsp;</tt>Layout</h3>
<p>
Section <a href="lexemes.html#lexemes-layout">2.7</a> gives an informal discussion of the layout
rule. This section defines it more precisely.<p>
The meaning of a Haskell program may depend on its <I>layout</I>.
The effect of layout on its meaning can be completely described by adding
braces and semicolons in places determined by the layout.  The meaning of
this augmented program is now layout insensitive.<p>
The effect of layout is specified in this section by describing
how to add braces and semicolons to a laid-out program.  The specification
takes the form of a function <I>L</I> that performs the translation.
The input to <I>L</I> is:
<UL><LI>
A stream of lexemes as specified by the lexical syntax in the Haskell report,
with the following additional tokens: 
<UL><LI>If a <tt>let</tt>, <tt>where</tt>, <tt>do</tt>, or <tt>of</tt> keyword is not followed by the lexeme <tt>{</tt>, 
the token <I>{n}</I> is inserted after the keyword, where <I>n</I> is the indentation of the 
next lexeme if there is one, or <I>0</I> if the end of file has been reached.
<LI>If the first lexeme of a module is not <tt>{</tt> or <tt>module</tt>, 
then it is preceded by <I>{n}</I> where <I>n</I> is the indentation of the lexeme. 
<LI>Where the start of a lexeme is preceded only by white space on the
   same line, this lexeme is preceded by <I>&lt;n&gt;</I> where <I>n
</I>   is the indentation of the lexeme, provided that it is not,
   as a consequence of the first two rules, preceded by <I>{n}</I>.
   (NB: a string literal may span multiple lines -- Section <a href="lexemes.html#lexemes-char">2.6</a>.  So in the fragment
<tt><br>

<br>
&nbsp;&nbsp;f&nbsp;=&nbsp;("Hello&nbsp;\<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\Bill",&nbsp;"Jake")<br>

<br>

</tt>There is no <I>&lt;n&gt;</I> inserted before the <tt>\Bill</tt>, because it is not the beginning of
a complete lexeme; nor before the <tt>,</tt>, because it is not preceded only by white space.)
</UL><p>
<LI>A stack of "layout contexts", in which each element is either:
<UL><LI>Zero, indicating that the enclosing context is explicit (i.e. the programmer 
supplied the opening brace. 
If the innermost context is 0, then no layout tokens will be inserted 
until either the enclosing context ends or a new context is pushed. 
<LI>A positive integer, which is the indentation column of the enclosing layout context. 
</UL>
</UL><p>
The "indentation" of a lexeme is the column number
of the first character of that lexeme; the indentation of a line is the
indentation of its leftmost lexeme.  To determine the column number,
assume a fixed-width font with the following conventions:
<UL><LI>The characters <I>newline</I>, <I>return</I>, <I>linefeed</I>, and <I>formfeed</I>, all start a new line.
<LI>The first column is designated column 1, not 0.
<LI>Tab stops are 8 characters apart.
<LI>A tab character causes the insertion of
enough spaces to align the current position with the next tab stop.
</UL>
For the purposes of the layout rule, Unicode characters in a source program
are considered to be of the same, fixed, width as an ASCII character.
However, to avoid visual confusion, programmers should avoid writing programs in which 
the meaning of implicit layout depends on the width of non-space characters.<p>
The application
<p>

L tokens []
<p>

delivers a layout-insensitive translation of <I>tokens</I>, where <I>tokens
</I>is the result of lexically analysing a module and adding column-number
indicators to it as described above.
The definition of <I>L</I> is as follows, where we use "<I>:</I>" as a stream
construction operator, and "<I>[]</I>" for the empty stream.
<div align=center><p>
<table >
<tr><td>
     L  (&lt;n&gt;:ts)  (m:ms)   </td><td align=center> = </td><td> <tt>;</tt>  :  (L  ts (m:ms))           </td><td>if  m = n </td></tr><tr><td></td><td align=center> = </td><td> <tt>}</tt>  :  (L  (&lt;n&gt;:ts)  ms)       </td><td> if  n &lt; m </td></tr><tr><td>L  (&lt;n&gt;:ts) ms        </td><td align=center> = </td><td> L  ts ms </td></tr><tr></tr><tr><td>L  ({n}:ts)  (m:ms)   </td><td align=center> = </td><td> <tt>{</tt>  :  (L  ts (n:m:ms))      </td><td> if n &gt; m    (Note  1)</td></tr><tr><td>L  ({n}:ts)  []       </td><td align=center> = </td><td> <tt>{</tt>  :  (L  ts [n])           </td><td> if n &gt; 0    (Note  1)</td></tr><tr><td>L  ({n}:ts)  ms 	     </td><td align=center> = </td><td> <tt>{</tt>  :  <tt>}</tt>  :   (L  (&lt;n&gt;:ts) ms) </td><td> (Note  2)</td></tr><tr></tr><tr><td>L  (<tt>}</tt>:ts)  (0:ms)     </td><td align=center> = </td><td> <tt>}</tt>  :  (L  ts ms)     	</td><td> (Note  3) </td></tr><tr><td>L  (<tt>}</tt>:ts)  ms         </td><td align=center> = </td><td> parse-error	 	</td><td> (Note  3) </td></tr><tr></tr><tr><td>L  (<tt>{</tt>:ts)  ms         </td><td align=center> = </td><td> <tt>{</tt>  :  (L  ts (0:ms))       </td><td>     (Note  4)</td></tr><tr></tr><tr><td>L  (t:ts)  (m:ms)       </td><td align=center> = </td><td> <tt>}</tt>  :  (L  (t:ts)  ms)      </td><td> if  m /= 0  and  parse-error(t) </td></tr><tr><td></td><td align=center></td><td></td><td> (Note  5) </td></tr><tr><td>L  (t:ts)  ms           </td><td align=center> = </td><td> t  :  (L  ts ms)</td></tr><tr></tr><tr><td>L  []  []		   </td><td align=center> = </td><td> []</td></tr><tr><td>L  []  (m:ms)	   </td><td align=center> = </td><td> <tt>}</tt>  :  L  []  ms	   </td><td> if m /=0   (Note  6)
</td></tr></table>
<p>

</div>
<DL><DT>
Note 1.
</DT>
 A nested context must be further indented 
than the enclosing context (<I>n&gt;m</I>). If not, <I>L</I> fails, and the compiler should indicate a
layout error.  An example is:
<tt><br>

<br>
&nbsp;&nbsp;f&nbsp;x&nbsp;=&nbsp;let<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h&nbsp;y&nbsp;=&nbsp;let<br>
&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;z&nbsp;=&nbsp;z<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in&nbsp;p<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in&nbsp;h<br>

<br>

</tt>Here, the definition of <tt>p</tt> is indented less than the indentation of
the enclosing context, which is set in this case by the definition of <tt>h</tt>.<p>
<DT>
Note 2.
</DT>
 If the first token after a <tt>where</tt> (say) is not indented more
than the enclosing layout context, then the block must be empty, so empty
braces are inserted.  The {n} token is replaced by &lt;n&gt;, to mimic the
situation if the empty braces had been explicit.<p>
<DT>
Note 3.
</DT>
 By matching against 0 for the current layout context, 
we ensure that an explicit close brace can only match an explicit open brace. 
A parse error results if an explicit close brace matches an implicit open brace.<p>
<DT>
Note 4.
</DT>
 This clause means that all brace pairs are treated as explicit layout 
contexts, including labelled construction and update (Section <a href="exps.html#field-ops">3.15</a>). 
This is a difference between this formulation and Haskell 1.4.<p>
<DT>
Note 5.
</DT>
 The side condition <I>parse-error(t)</I> is to be interpreted as follows: 
if the tokens generated so far by <I>L</I> together with the next token <I>t</I> 
represent an invalid prefix of the Haskell grammar, and the 
tokens generated so far by <I>L</I> followed by the token "<tt>}</tt>"
represent a valid prefix of the Haskell grammar, then <I>parse-error(t)</I> is true. <p>
The test m /= 0 checks that an implicitly-added closing brace would match
an implicit open brace.<p>
<DT>
Note 6.
</DT>
 At the end of the input, any pending close-braces are inserted. 
It is an error at this point to be within a non-layout context (i.e.  <I>m = 0</I>). 
</DL><p>
If none of the rules given above matches, then the algorithm fails. It
can fail for instance when the end of the input is reached, and a
non-layout context is active, since the close brace is missing. Some
error conditions are not detected by the algorithm, although they
could be: for example <tt>let&nbsp;}</tt>.<p>
Note 1 implements the feature that layout processing can be stopped
prematurely by a parse error.  For example
<tt><br>

<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;x&nbsp;=&nbsp;e;&nbsp;y&nbsp;=&nbsp;x&nbsp;in&nbsp;e'<br>

<br>

</tt>is valid, because it translates to 
<tt><br>

<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;{&nbsp;x&nbsp;=&nbsp;e;&nbsp;y&nbsp;=&nbsp;x&nbsp;}&nbsp;in&nbsp;e'<br>

<br>

</tt>The close brace is inserted due to the parse error rule above.
The parse-error rule is hard to implement in its full generality, because 
doing so involves fixities.  For example, the expression
<tt><br>

<br>
&nbsp;&nbsp;do&nbsp;a&nbsp;==&nbsp;b&nbsp;==&nbsp;c<br>

<br>

</tt>has a single unambiguous (albeit probably type-incorrect) parse, namely
<tt><br>

<br>
&nbsp;&nbsp;(do&nbsp;{&nbsp;a&nbsp;==&nbsp;b&nbsp;})&nbsp;==&nbsp;c<br>

<br>

</tt>because <tt>(==)</tt> is non-associative.   Programmers are therefore advised to avoid
writing code that requires the parser to insert a closing brace in such
situations.<a name="literate"></a><p>

<a name="sect9.4"></a>
<h3>9.4<tt>&nbsp;&nbsp;</tt>Literate comments</h3>
<p>
The "literate comment"
convention, first developed by Richard Bird and Philip Wadler for
Orwell, and inspired in turn by Donald Knuth's "literate
programming", is an alternative style for encoding Haskell  source
code. 
The literate style encourages comments by making them the default.  A
line in which "<tt>&gt;</tt>" is the first character is treated as part of the
program; all other lines are comment.<p>
The program text is recovered
by taking only those lines beginning with "<tt>&gt;</tt>", 
and replacing the leading "<tt>&gt;</tt>" with a space.
Layout and comments apply
exactly as described in Chapter <a href="syntax-iso.html#syntax">9</a> in the resulting text.<p>
To capture some cases where one omits an "<tt>&gt;</tt>" by mistake, it is an
error for a program line to appear adjacent to a non-blank comment line,
where a line is taken as blank if it consists only of whitespace.<p>
By convention, the style of comment is indicated by the file
extension, with "<tt>.hs</tt>" indicating a usual Haskell file and
"<tt>.lhs</tt>" indicating a literate Haskell file.  Using this style, a
simple factorial program would be:
<tt><br>

<br>
&nbsp;&nbsp;&nbsp;This&nbsp;literate&nbsp;program&nbsp;prompts&nbsp;the&nbsp;user&nbsp;for&nbsp;a&nbsp;number<br>
&nbsp;&nbsp;&nbsp;and&nbsp;prints&nbsp;the&nbsp;factorial&nbsp;of&nbsp;that&nbsp;number:<br>
<br>
&gt;&nbsp;main&nbsp;::&nbsp;IO&nbsp;()<br>
<br>
&gt;&nbsp;main&nbsp;=&nbsp;do&nbsp;putStr&nbsp;"Enter&nbsp;a&nbsp;number:&nbsp;"<br>
&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l&nbsp;&lt;-&nbsp;readLine<br>
&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;putStr&nbsp;"n!=&nbsp;"<br>
&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;(fact&nbsp;(read&nbsp;l))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;This&nbsp;is&nbsp;the&nbsp;factorial&nbsp;function.<br>
<br>
&gt;&nbsp;fact&nbsp;::&nbsp;Integer&nbsp;-&gt;&nbsp;Integer<br>
&gt;&nbsp;fact&nbsp;0&nbsp;=&nbsp;1<br>
&gt;&nbsp;fact&nbsp;n&nbsp;=&nbsp;n&nbsp;*&nbsp;fact&nbsp;(n-1)<br>

<br>
<p>
</tt>An alternative style of literate programming is particularly
suitable for use with the LaTeX text processing system.
In this convention, only those parts of the literate program that are
entirely enclosed between <tt>\begin{code}</tt>...<tt>\end{code}</tt> delimiters are
treated as program text; all other lines are comment.  More precisely:
<UL><LI>Program code begins on the first line following a line that begins <tt>\begin{code}</tt>.
<LI>Program code ends just before a subsequent line that begins <tt>\end{code}</tt> (ignoring
string literals, of course).
</UL>
It is not necessary
to insert additional blank lines before or after these delimiters, though
it may be stylistically desirable.  For example,
<tt><br>

<br>
\documentstyle{article}<br>
<br>
\begin{document}<br>
<br>
\section{Introduction}<br>
<br>
This&nbsp;is&nbsp;a&nbsp;trivial&nbsp;program&nbsp;that&nbsp;prints&nbsp;the&nbsp;first&nbsp;20&nbsp;factorials.<br>
<br>
\begin{code}<br>
main&nbsp;::&nbsp;IO&nbsp;()<br>
main&nbsp;=&nbsp;&nbsp;print&nbsp;[&nbsp;(n,&nbsp;product&nbsp;[1..n])&nbsp;|&nbsp;n&nbsp;&lt;-&nbsp;[1..20]]<br>
\end{code}<br>
<br>
\end{document}<br>

<br>

</tt>This style uses the same file extension.  It is not advisable to mix
these two styles in the same file.<a name="bnf"></a><p>

<a name="sect9.5"></a>
<h3>9.5<tt>&nbsp;&nbsp;</tt>Context-Free Syntax</h3>

<table cellspacing=0 cellspacing=0>
<tr><td width=100></td><td width=20></td><td width=250></td></tr><tr><td>
module </td><td>  <tt>-&gt;</tt> </td><td> <tt>module</tt> modid [exports] <tt>where</tt> body 
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  body
</td></tr><tr><td>
body </td><td>  <tt>-&gt;</tt> </td><td> <tt>{</tt> impdecls <tt>;</tt> topdecls <tt>}
</tt></td></tr><tr><td>
</td><td> <tt>|</tt> </td><td> <tt>{</tt> impdecls  <tt>}
</tt></td></tr><tr><td>
</td><td> <tt>|</tt> </td><td> <tt>{</tt> topdecls  <tt>}
</tt></td></tr><tr><td>
impdecls </td><td>  <tt>-&gt;</tt> </td><td> impdecl<sub>1</sub> <tt>;</tt> ... <tt>;</tt> impdecl<sub>n</sub> 	</td><td>  (n&gt;=1)
</td></tr></table>
<p>
<table cellspacing=0 cellspacing=0>
<tr><td width=100></td><td width=20></td><td width=250></td></tr><tr><td>
exports </td><td>  <tt>-&gt;</tt> </td><td> <tt>(</tt> export<sub>1</sub> <tt>,</tt> ... <tt>,</tt> export<sub>n</sub> [ <tt>,</tt> ] <tt>)</tt> </td><td> (n&gt;=0)
</td></tr><tr><td>
export </td><td>  <tt>-&gt;</tt> </td><td> qvar
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  qtycon [<tt>(..)</tt> | <tt>(</tt> cname<sub>1</sub> <tt>,</tt> ... <tt>,</tt> cname<sub>n</sub> <tt>)</tt>] </td><td> (n&gt;=0)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  qtycls [<tt>(..)</tt> | <tt>(</tt> qvar<sub>1</sub> <tt>,</tt> ... <tt>,</tt> qvar<sub>n</sub> <tt>)</tt>] </td><td> (n&gt;=0)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>module</tt> modid
</td></tr></table>
<p>
<table cellspacing=0 cellspacing=0>
<tr><td width=100></td><td width=20></td><td width=250></td></tr><tr></tr><tr><td>
impdecl </td><td>  <tt>-&gt;</tt> </td><td> <tt>import</tt> [<tt>qualified</tt>] modid [<tt>as</tt> modid] [impspec]
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td> 	</td><td> (empty declaration)
</td></tr><tr><td>
impspec </td><td>  <tt>-&gt;</tt> </td><td> <tt>(</tt> import<sub>1</sub> <tt>,</tt> ... <tt>,</tt> import<sub>n</sub> [ <tt>,</tt> ] <tt>)</tt> </td><td> (n&gt;=0)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>hiding</tt> <tt>(</tt> import<sub>1</sub> <tt>,</tt> ... <tt>,</tt> import<sub>n</sub> [ <tt>,</tt> ] <tt>)</tt> </td><td>  (n&gt;=0)
</td></tr><tr><td>
import </td><td>  <tt>-&gt;</tt> </td><td> var
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  tycon [ <tt>(..)</tt> | <tt>(</tt> cname<sub>1</sub> <tt>,</tt> ... <tt>,</tt> cname<sub>n</sub> <tt>)</tt>] </td><td> (n&gt;=0)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  tycls [<tt>(..)</tt> | <tt>(</tt> var<sub>1</sub> <tt>,</tt> ... <tt>,</tt> var<sub>n</sub> <tt>)</tt>] </td><td> (n&gt;=0)
</td></tr><tr><td>
cname </td><td>  <tt>-&gt;</tt> </td><td> var | con
</td></tr></table>
<p>
<table cellspacing=0 cellspacing=0>
<tr><td width=100>
topdecls </td><td width=20>  <tt>-&gt;</tt> </td><td width=250> topdecl<sub>1</sub> <tt>;</tt> ... <tt>;</tt> topdecl<sub>n</sub> 	</td><td>  (n&gt;=0)
</td></tr><tr><td>
topdecl </td><td>  <tt>-&gt;</tt> </td><td> <tt>type</tt> simpletype <tt>=</tt> type
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>data</tt> [context <tt>=&gt;</tt>] simpletype <tt>=</tt> constrs [deriving]
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>newtype</tt> [context <tt>=&gt;</tt>] simpletype <tt>=</tt> newconstr [deriving]
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>class</tt> [scontext <tt>=&gt;</tt>] tycls tyvar [<tt>where</tt> cdecls]
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>instance</tt> [scontext <tt>=&gt;</tt>] qtycls inst [<tt>where</tt> idecls]
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>default</tt> <tt>(</tt>type<sub>1</sub> <tt>,</tt> ... <tt>,</tt> type<sub>n</sub><tt>)</tt> </td><td> (n&gt;=0)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  decl
</td></tr></table>
<p>
<table cellspacing=0 cellspacing=0>
<tr><td width=100></td><td width=20></td><td width=250></td></tr><tr></tr><tr></tr><tr></tr><tr><td>
decls </td><td>  <tt>-&gt;</tt> </td><td> <tt>{</tt> decl<sub>1</sub> <tt>;</tt> ... <tt>;</tt> decl<sub>n</sub>  <tt>}</tt>		</td><td>  (n&gt;=0)
</td></tr><tr><td>
decl </td><td>  <tt>-&gt;</tt> </td><td> gendecl
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  (funlhs | pat<sup>0</sup>) rhs
</td></tr><tr><td>
cdecls </td><td>  <tt>-&gt;</tt> </td><td> <tt>{</tt> cdecl<sub>1</sub> <tt>;</tt> ... <tt>;</tt> cdecl<sub>n</sub>  <tt>}</tt>		</td><td>  (n&gt;=0)
</td></tr><tr><td>
cdecl </td><td>  <tt>-&gt;</tt> </td><td> gendecl
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  (funlhs | var) rhs
</td></tr><tr><td>
idecls </td><td>  <tt>-&gt;</tt> </td><td> <tt>{</tt> idecl<sub>1</sub> <tt>;</tt> ... <tt>;</tt> idecl<sub>n</sub>  <tt>}</tt>		</td><td>  (n&gt;=0)
</td></tr><tr><td>
idecl </td><td>  <tt>-&gt;</tt> </td><td> (funlhs | var) rhs
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>						</td><td> (empty)
</td></tr><tr><td>
gendecl </td><td>  <tt>-&gt;</tt> </td><td> vars <tt>::</tt> [context <tt>=&gt;</tt>] type	</td><td> (type signature)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  fixity [integer] ops			</td><td> (fixity declaration)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>					</td><td> (empty declaration)
</td></tr><tr><td>
ops </td><td>  <tt>-&gt;</tt> </td><td> op<sub>1</sub> <tt>,</tt> ... <tt>,</tt> op<sub>n</sub>		</td><td> (n&gt;=1)
</td></tr><tr><td>
vars </td><td>  <tt>-&gt;</tt> </td><td> var<sub>1</sub> <tt>,</tt> ...<tt>,</tt> var<sub>n</sub>		</td><td> (n&gt;=1)
</td></tr><tr><td>
fixity </td><td>  <tt>-&gt;</tt> </td><td> <tt>infixl</tt> | <tt>infixr</tt> | <tt>infix
</tt></td></tr></table>
<p>
<table cellspacing=0 cellspacing=0>
<tr><td width=100></td><td width=20></td><td width=250></td></tr><tr></tr><tr></tr><tr></tr><tr><td>
type </td><td>  <tt>-&gt;</tt> </td><td> btype [<tt>-&gt;</tt> type]                    </td><td> (function type)
</td></tr><tr><td>
btype </td><td>  <tt>-&gt;</tt> </td><td>  [btype] atype                        </td><td> (type application)
</td></tr><tr><td>
atype </td><td>  <tt>-&gt;</tt> </td><td>  gtycon
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  tyvar
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>(</tt> type<sub>1</sub> <tt>,</tt> ... <tt>,</tt> type<sub>k</sub> <tt>)</tt> </td><td> (tuple type, k&gt;=2)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>[</tt> type <tt>]</tt>                      </td><td> (list type)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>(</tt> type <tt>)</tt>                      </td><td> (parenthesized constructor)
</td></tr><tr><td>
gtycon </td><td>  <tt>-&gt;</tt> </td><td> qtycon
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>()</tt>                              </td><td> (unit type)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>[]</tt>                              </td><td> (list constructor)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>(-&gt;)</tt>                            </td><td> (function constructor)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>(,</tt>{<tt>,</tt>}<tt>)</tt>                    </td><td> (tupling constructors)
</td></tr><tr><td>
context </td><td>  <tt>-&gt;</tt> </td><td> class
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>(</tt> class<sub>1</sub> <tt>,</tt> ... <tt>,</tt> class<sub>n</sub> <tt>)</tt>		</td><td>  (n&gt;=0)
</td></tr><tr><td>
class </td><td>  <tt>-&gt;</tt> </td><td> qtycls tyvar			
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  qtycls <tt>(</tt> tyvar atype<sub>1</sub> ...  atype<sub>n</sub> <tt>)</tt> </td><td>  (n&gt;=1)
</td></tr><tr><td>
scontext </td><td>  <tt>-&gt;</tt> </td><td> simpleclass
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>(</tt> simpleclass<sub>1</sub> <tt>,</tt> ... <tt>,</tt> simpleclass<sub>n</sub> <tt>)</tt>		</td><td>  (n&gt;=0)
</td></tr><tr><td>
simpleclass </td><td>  <tt>-&gt;</tt> </td><td> qtycls tyvar			
</td></tr></table>
<p>
<table cellspacing=0 cellspacing=0>
<tr><td width=100>
simpletype </td><td width=20>  <tt>-&gt;</tt> </td><td width=250> tycon tyvar<sub>1</sub> ... tyvar<sub>k</sub> </td><td>  (k&gt;=0)
</td></tr><tr><td>
constrs </td><td>  <tt>-&gt;</tt> </td><td> constr<sub>1</sub> <tt>|</tt> ... <tt>|</tt> constr<sub>n</sub>	</td><td>  (n&gt;=1)
</td></tr><tr><td>
constr </td><td>  <tt>-&gt;</tt> </td><td> con [<tt>!</tt>] atype<sub>1</sub> ... [<tt>!</tt>] atype<sub>k</sub>	</td><td> (arity con = k, k&gt;=0)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  (btype | <tt>!</tt> atype) conop (btype | <tt>!</tt> atype) </td><td> (infix conop)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  con <tt>{</tt> fielddecl<sub>1</sub> <tt>,</tt> ... <tt>,</tt> fielddecl<sub>n</sub> <tt>}</tt> </td><td>  (n&gt;=0)
</td></tr><tr><td>
newconstr </td><td>  <tt>-&gt;</tt> </td><td> con atype
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  con <tt>{</tt> var <tt>::</tt> type <tt>}</tt> 
</td></tr><tr><td>
fielddecl </td><td>  <tt>-&gt;</tt> </td><td> vars <tt>::</tt> (type | <tt>!</tt> atype)
</td></tr><tr><td>
deriving </td><td>  <tt>-&gt;</tt> </td><td> <tt>deriving</tt> (dclass | <tt>(</tt>dclass<sub>1</sub><tt>,</tt> ... <tt>,</tt> dclass<sub>n</sub><tt>)</tt>)</td><td>  (n&gt;=0)
</td></tr><tr><td>
dclass </td><td>  <tt>-&gt;</tt> </td><td> qtycls
</td></tr></table>
<p>
<table cellspacing=0 cellspacing=0>
<tr><td width=100>
inst </td><td width=20>  <tt>-&gt;</tt> </td><td width=250> gtycon
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>(</tt> gtycon tyvar<sub>1</sub> ... tyvar<sub>k</sub> <tt>)</tt>	</td><td> (k&gt;=0, tyvars distinct)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>(</tt> tyvar<sub>1</sub> <tt>,</tt> ... <tt>,</tt> tyvar<sub>k</sub> <tt>)</tt>	</td><td> (k&gt;=2, tyvars distinct)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>[</tt> tyvar <tt>]
</tt></td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>(</tt> tyvar<sub>1</sub> <tt>-&gt;</tt> tyvar<sub>2</sub> <tt>)</tt>		</td><td> tyvar<sub>1</sub> and tyvar<sub>2</sub> distinct
</td></tr></table>
<p>
<table cellspacing=0 cellspacing=0>
<tr><td width=100></td><td width=20></td><td width=250></td></tr><tr></tr><tr></tr><tr><td>
funlhs </td><td>  <tt>-&gt;</tt> </td><td>  var apat {apat }
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   pat<sup>i+1</sup> varop<sup>(a,i)</sup> pat<sup>i+1</sup>
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   lpat<sup>i</sup> varop<sup>(l,i)</sup> pat<sup>i+1</sup>
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   pat<sup>i+1</sup> varop<sup>(r,i)</sup> rpat<sup>i</sup>
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   <tt>(</tt> funlhs <tt>)</tt>  apat {apat }
</td></tr><tr><td>
rhs </td><td>  <tt>-&gt;</tt> </td><td>  <tt>=</tt> exp [<tt>where</tt> decls]
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   gdrhs [<tt>where</tt> decls]
</td></tr><tr><td>
gdrhs </td><td>  <tt>-&gt;</tt> </td><td>  gd <tt>=</tt> exp [gdrhs]
</td></tr><tr><td>
gd </td><td>  <tt>-&gt;</tt> </td><td>  <tt>|</tt> exp<sup>0</sup> 
</td></tr></table>
<p>
<table cellspacing=0 cellspacing=0>
<tr><td width=100>
exp </td><td width=20>  <tt>-&gt;</tt> </td><td width=250>  exp<sup>0</sup> <tt>::</tt> [context <tt>=&gt;</tt>] type	</td><td> (expression type signature)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   exp<sup>0</sup>
</td></tr><tr><td>
exp<sup>i</sup> </td><td>  <tt>-&gt;</tt> </td><td>  exp<sup>i+1</sup> [qop<sup>(n,i)</sup> exp<sup>i+1</sup>]
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   lexp<sup>i</sup>
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   rexp<sup>i</sup>
</td></tr><tr><td>
lexp<sup>i</sup> </td><td>  <tt>-&gt;</tt> </td><td>  (lexp<sup>i</sup> | exp<sup>i+1</sup>) qop<sup>(l,i)</sup> exp<sup>i+1</sup>
</td></tr><tr><td>
lexp<sup>6</sup> </td><td>  <tt>-&gt;</tt> </td><td>  <tt>-</tt> exp<sup>7</sup>
</td></tr><tr><td>
rexp<sup>i</sup> </td><td>  <tt>-&gt;</tt> </td><td>  exp<sup>i+1</sup> qop<sup>(r,i)</sup> (rexp<sup>i</sup> | exp<sup>i+1</sup>)
</td></tr><tr><td>
exp<sup>10</sup> </td><td>  <tt>-&gt;</tt> </td><td>  <tt>\</tt> apat<sub>1</sub> ... apat<sub>n</sub> <tt>-&gt;</tt> exp	</td><td> (lambda abstraction, n&gt;=1)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   <tt>let</tt> decls <tt>in</tt> exp	        </td><td> (let expression)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   <tt>if</tt> exp <tt>then</tt> exp <tt>else</tt> exp	</td><td> (conditional)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   <tt>case</tt> exp <tt>of</tt> <tt>{</tt> alts <tt>}</tt>	</td><td> (case expression)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   <tt>do</tt> <tt>{</tt> stmts  <tt>}</tt>            </td><td> (do expression)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   fexp
</td></tr><tr><td>
fexp </td><td>  <tt>-&gt;</tt> </td><td>  [fexp] aexp				</td><td> (function application)
</td></tr></table>
<p>
<table cellspacing=0 cellspacing=0>
<tr><td width=100>
aexp </td><td width=20>  <tt>-&gt;</tt> </td><td width=250>  qvar				</td><td> (variable)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   gcon				</td><td> (general constructor)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   literal				
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   <tt>(</tt> exp <tt>)</tt>			      </td><td> (parenthesized expression)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   <tt>(</tt> exp<sub>1</sub> <tt>,</tt> ... <tt>,</tt> exp<sub>k</sub> <tt>)</tt>	</td><td> (tuple, k&gt;=2)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   <tt>[</tt> exp<sub>1</sub> <tt>,</tt> ... <tt>,</tt> exp<sub>k</sub> <tt>]</tt>	</td><td> (list, k&gt;=1)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   <tt>[</tt> exp<sub>1</sub> [<tt>,</tt> exp<sub>2</sub>] <tt>..</tt> [exp<sub>3</sub>] <tt>]</tt> </td><td> (arithmetic sequence)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   <tt>[</tt> exp <tt>|</tt> qual<sub>1</sub> <tt>,</tt> ... <tt>,</tt> qual<sub>n</sub> <tt>]</tt>	</td><td> (list comprehension, n&gt;=1)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   <tt>(</tt> exp<sup>i+1</sup> qop<sup>(a,i)</sup> <tt>)</tt>        </td><td> (left section)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   <tt>(</tt> lexp<sup>i</sup> qop<sup>(l,i)</sup> <tt>)</tt>        </td><td> (left section)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   <tt>(</tt> qop<sup>(a,i)</sup><sub>&lt;<tt>-</tt>&gt;</sub>  exp<sup>i+1</sup> <tt>)</tt>        </td><td> (right section)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   <tt>(</tt> qop<sup>(r,i)</sup><sub>&lt;<tt>-</tt>&gt;</sub>  rexp<sup>i</sup> <tt>)</tt>        </td><td> (right section)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   qcon <tt>{</tt> fbind<sub>1</sub> <tt>,</tt> ... <tt>,</tt> fbind<sub>n</sub> <tt>}</tt> </td><td> (labeled construction, n&gt;=0)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   aexp<sub>&lt;qcon&gt;</sub> <tt>{</tt> fbind<sub>1</sub> <tt>,</tt> ... <tt>,</tt> fbind<sub>n</sub> <tt>}</tt> </td><td> (labeled update, n &gt;= 1)
</td></tr></table>
<p>
<table cellspacing=0 cellspacing=0>
<tr><td width=100></td><td width=20></td><td width=250></td></tr><tr></tr><tr></tr><tr></tr><tr><td>
qual </td><td>  <tt>-&gt;</tt> </td><td> pat <tt>&lt;-</tt> exp 	</td><td> (generator)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td> <tt>let</tt> decls		</td><td> (local declaration)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td> exp 			</td><td> (guard)
</td></tr><tr><td>
alts </td><td>  <tt>-&gt;</tt> </td><td>  alt<sub>1</sub> <tt>;</tt> ... <tt>;</tt> alt<sub>n</sub> 		</td><td>  (n&gt;=1)
</td></tr><tr><td>
alt </td><td>  <tt>-&gt;</tt> </td><td>  pat <tt>-&gt;</tt> exp [<tt>where</tt> decls]
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   pat gdpat [<tt>where</tt> decls]
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>					</td><td> (empty alternative)
</td></tr><tr><td>
gdpat </td><td>  <tt>-&gt;</tt> </td><td>  gd <tt>-&gt;</tt> exp [ gdpat ]
</td></tr><tr><td>
stmts </td><td>  <tt>-&gt;</tt> </td><td> stmt<sub>1</sub> ... stmt<sub>n</sub> exp [<tt>;</tt>]  </td><td>  (n&gt;=0)
</td></tr><tr><td>
stmt </td><td>  <tt>-&gt;</tt> </td><td> exp <tt>;
</tt></td></tr><tr><td>
</td><td> <tt>|</tt> </td><td> pat <tt>&lt;-</tt> exp <tt>;
</tt></td></tr><tr><td>
</td><td> <tt>|</tt> </td><td> <tt>let</tt> decls <tt>;
</tt></td></tr><tr><td>
</td><td> <tt>|</tt> </td><td> <tt>;</tt>			</td><td> (empty statement)
</td></tr><tr><td>
fbind </td><td>  <tt>-&gt;</tt> </td><td>  qvar <tt>=</tt> exp
</td></tr><tr><td>
 </td><td> 
</td></tr></table>
<p>
<table cellspacing=0 cellspacing=0>
<tr><td width=100>
pat </td><td width=20>  <tt>-&gt;</tt> </td><td width=250>  var <tt>+</tt> integer </td><td> (successor pattern)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  pat<sup>0</sup>
</td></tr><tr><td>
pat<sup>i</sup> </td><td>  <tt>-&gt;</tt> </td><td>  pat<sup>i+1</sup> [qconop<sup>(n,i)</sup> pat<sup>i+1</sup>]
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   lpat<sup>i</sup>
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   rpat<sup>i</sup>
</td></tr><tr><td>
lpat<sup>i</sup> </td><td>  <tt>-&gt;</tt> </td><td>  (lpat<sup>i</sup> | pat<sup>i+1</sup>) qconop<sup>(l,i)</sup> pat<sup>i+1</sup>
</td></tr><tr><td>
lpat<sup>6</sup> </td><td>  <tt>-&gt;</tt> </td><td>  <tt>-</tt> (integer | float)		</td><td> (negative literal)
</td></tr><tr><td>
rpat<sup>i</sup> </td><td>  <tt>-&gt;</tt> </td><td>  pat<sup>i+1</sup> qconop<sup>(r,i)</sup> (rpat<sup>i</sup> | pat<sup>i+1</sup>)
</td></tr><tr><td>
pat<sup>10</sup> </td><td>  <tt>-&gt;</tt> </td><td>  apat
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   gcon apat<sub>1</sub> ... apat<sub>k</sub>		</td><td> (arity gcon = k, k&gt;=1)
</td></tr></table>
<p>
<table cellspacing=0 cellspacing=0>
<tr><td width=100></td><td width=20></td><td width=250></td></tr><tr><td>
apat </td><td>  <tt>-&gt;</tt> </td><td>  var [<tt>@</tt> apat]			</td><td> (as pattern)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   gcon				</td><td> (arity gcon = 0) 
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   qcon <tt>{</tt> fpat<sub>1</sub> <tt>,</tt> ... <tt>,</tt> fpat<sub>k</sub> <tt>}</tt> </td><td> (labeled pattern, k&gt;=0)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   literal
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   <tt>_</tt>					</td><td> (wildcard)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   <tt>(</tt> pat <tt>)</tt>				</td><td> (parenthesized pattern)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   <tt>(</tt> pat<sub>1</sub> <tt>,</tt> ... <tt>,</tt> pat<sub>k</sub> <tt>)</tt>	</td><td> (tuple pattern, k&gt;=2)
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   <tt>[</tt> pat<sub>1</sub> <tt>,</tt> ... <tt>,</tt> pat<sub>k</sub> <tt>]</tt>	</td><td> (list pattern, k&gt;=1) 
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   <tt>~</tt> apat				</td><td> (irrefutable pattern)
</td></tr><tr><td>
fpat </td><td>  <tt>-&gt;</tt> </td><td>  qvar <tt>=</tt> pat
</td></tr></table>
<table cellspacing=0 cellspacing=0>
<tr><td width=100></td><td width=20></td><td width=250></td></tr><tr><td>
gcon </td><td>  <tt>-&gt;</tt> </td><td>  <tt>()
</tt></td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   <tt>[]
</tt></td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   <tt>(,</tt>{<tt>,</tt>}<tt>)
</tt></td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>   qcon
</td></tr><tr><td>
var </td><td>  <tt>-&gt;</tt> </td><td>  varid | <tt>(</tt> varsym <tt>)</tt>		</td><td> (variable)
</td></tr><tr><td>
qvar </td><td>  <tt>-&gt;</tt> </td><td>  qvarid | <tt>(</tt> qvarsym <tt>)</tt>		</td><td> (qualified variable)
</td></tr><tr><td>
con </td><td>  <tt>-&gt;</tt> </td><td>  conid | <tt>(</tt> consym <tt>)</tt>		</td><td> (constructor)
</td></tr><tr><td>
qcon </td><td>  <tt>-&gt;</tt> </td><td>  qconid | <tt>(</tt> gconsym <tt>)</tt>		</td><td> (qualified constructor)
</td></tr><tr><td>
varop </td><td>  <tt>-&gt;</tt> </td><td>  varsym | `varid `</td><td> (variable operator)
</td></tr><tr><td>
qvarop </td><td>  <tt>-&gt;</tt> </td><td>  qvarsym | `qvarid `</td><td> (qualified variable operator)
</td></tr><tr><td>
conop </td><td>  <tt>-&gt;</tt> </td><td>  consym | `conid `</td><td> (constructor operator)
</td></tr><tr><td>
qconop </td><td>  <tt>-&gt;</tt> </td><td>  gconsym | `qconid `</td><td> (qualified constructor operator)
</td></tr><tr><td>
op </td><td>  <tt>-&gt;</tt> </td><td>  varop | conop 			</td><td> (operator)
</td></tr><tr><td>
qop </td><td>  <tt>-&gt;</tt> </td><td>  qvarop | qconop			</td><td> (qualified operator)
</td></tr><tr><td>
gconsym </td><td>  <tt>-&gt;</tt> </td><td>  <tt>:</tt> | qconsym
</td></tr></table>
<p>
<hr><i>The Haskell 98 Report</i><br><a href="index.html">top</a> | <a href="standard-prelude.html">back</a> | <a href="literate.html">next</a> | <a href="index98.html">contents</a> | <a href="prelude-index.html">function index</a> <br><font size=2>December 2002</font>
<p>
