
<title>Haskell 98 Lexical Structure</title>
<body bgcolor="#ffffff"> <i>The Haskell 98 Report</i><br> <a href="index.html">top</a> | <a href="intro.html">back</a> | <a href="exps.html">next</a> | <a href="index98.html">contents</a> | <a href="prelude-index.html">function index</a> <br><hr>
<a name="lexical-structure"></a><a name="sect2"></a>
<h2>2<tt>&nbsp;&nbsp;</tt>Lexical Structure</h2>
<p>

In this chapter, 
we describe the low-level lexical structure of Haskell .
Most of the details may be skipped in a first reading of
the report.<a name="notational-conventions"></a><p>
<a name="sect2.1"></a>
<h3>2.1<tt>&nbsp;&nbsp;</tt>Notational Conventions</h3>
<p>
These notational conventions are used for presenting syntax:<p>
<p>
<table >
<tr><td align=center>
<I>[pattern]</I>		</td><td> optional </td></tr><tr><td align=center><I>{pattern}</I>		</td><td> zero or more repetitions </td></tr><tr><td align=center><I>(pattern)</I>		</td><td> grouping </td></tr><tr><td align=center><I>pat</I><sub><I>1</I></sub><I> | pat</I><sub><I>2</I></sub>		</td><td> choice </td></tr><tr><td align=center><I>pat</I><sub><I>&lt;pat'&gt;</I></sub>	</td><td> difference---elements generated by <I>pat</I> </td></tr><tr><td align=center></td><td> except those generated by <I>pat'</I> </td></tr><tr><td align=center><tt>fibonacci</tt>		</td><td> terminal syntax in typewriter font
</td></tr></table>
<p>
<p>
Because the syntax in this section describes <I>lexical</I> syntax, all
whitespace is expressed explicitly; there is no
implicit space between juxtaposed symbols.  BNF-like syntax is used
throughout, with productions having the form:
<table cellspacing=0 cellspacing=0>
<tr><td width=100>
nonterm </td><td width=20>  <tt>-&gt;</tt> </td><td width=250> alt<sub>1</sub> | alt<sub>2</sub> | ... | alt<sub>n</sub>
</td></tr></table>
<p>
Care must be taken in distinguishing metalogical syntax such as <I>|
</I>and <I>[...]</I> from concrete terminal syntax (given in typewriter font)
such as <tt>|</tt> and <tt>[...]</tt>, although usually the context makes the
distinction clear.<p>
Haskell  uses the Unicode [<a href="haskell.html#$unicode">11</a>] character set.

However, source 
programs are currently biased toward the ASCII character set
 used in earlier versions of Haskell .<p>
This syntax depends on properties of the Unicode characters as defined
by the Unicode consortium. 
Haskell  compilers are expected to make use of
new versions of Unicode as they are made available.<a name="lexemes"></a><p>
<a name="sect2.2"></a>
<h3>2.2<tt>&nbsp;&nbsp;</tt>Lexical Program Structure</h3>
<a name="whitespace"></a>
<p>
<table cellspacing=0 cellspacing=0>
<tr><td width=100></td><td width=20></td><td width=250></td></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr><td>
program </td><td>  <tt>-&gt;</tt> </td><td> {lexeme | whitespace }
</td></tr><tr><td>
lexeme </td><td>  <tt>-&gt;</tt> </td><td> qvarid | qconid | qvarsym | qconsym 
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td> literal | special | reservedop | reservedid
</td></tr><tr><td>
literal </td><td>  <tt>-&gt;</tt> </td><td> integer | float | char | string
</td></tr><tr><td>
special </td><td>  <tt>-&gt;</tt> </td><td> <tt>(</tt> | <tt>)</tt> | <tt>,</tt> | <tt>;</tt> | <tt>[</tt> | <tt>]</tt> | `| <tt>{</tt> | <tt>}
</tt></td></tr><tr><td>
whitespace </td><td>  <tt>-&gt;</tt> </td><td> whitestuff {whitestuff}
</td></tr><tr><td>
whitestuff </td><td>  <tt>-&gt;</tt> </td><td> whitechar | comment | ncomment
</td></tr><tr><td>
whitechar </td><td>  <tt>-&gt;</tt> </td><td> newline | vertab | space | tab | uniWhite
</td></tr><tr><td>
newline </td><td>  <tt>-&gt;</tt> </td><td> return linefeed | return | linefeed | formfeed
</td></tr><tr><td>
return </td><td>  <tt>-&gt;</tt> </td><td> a carriage return
</td></tr><tr><td>
linefeed </td><td>  <tt>-&gt;</tt> </td><td> a line feed
</td></tr><tr><td>
vertab </td><td>  <tt>-&gt;</tt> </td><td> a vertical tab
</td></tr><tr><td>
formfeed </td><td>  <tt>-&gt;</tt> </td><td> a form feed
</td></tr><tr><td>
space </td><td>  <tt>-&gt;</tt> </td><td> a space
</td></tr><tr><td>
tab </td><td>  <tt>-&gt;</tt> </td><td> a horizontal tab
</td></tr><tr><td>
uniWhite </td><td>  <tt>-&gt;</tt> </td><td> any Unicode character defined as whitespace
</td></tr><tr><td>
comment </td><td>  <tt>-&gt;</tt> </td><td> dashes [ any<sub>&lt;symbol&gt;</sub>  {any}] newline
</td></tr><tr><td>
dashes </td><td>  <tt>-&gt;</tt> </td><td> <tt>--</tt> {<tt>-</tt>}
</td></tr><tr><td>
opencom </td><td>  <tt>-&gt;</tt> </td><td> <tt>{-
</tt></td></tr><tr><td>
closecom </td><td>  <tt>-&gt;</tt> </td><td> <tt>-}
</tt></td></tr><tr><td>
ncomment </td><td>  <tt>-&gt;</tt> </td><td> opencom ANYseq {ncomment ANYseq}closecom
</td></tr><tr><td>
ANYseq </td><td>  <tt>-&gt;</tt> </td><td> {ANY}<sub>&lt;{ANY}( opencom | closecom ) {ANY}&gt;</sub>
</td></tr><tr><td>
ANY </td><td>  <tt>-&gt;</tt> </td><td> graphic | whitechar
</td></tr><tr><td>
any </td><td>  <tt>-&gt;</tt> </td><td> graphic | space | tab
</td></tr><tr><td>
graphic </td><td>  <tt>-&gt;</tt> </td><td> small | large | symbol | digit | special | <tt>:</tt> | <tt>"</tt> | <tt>'
</tt></td></tr><tr><td>
small </td><td>  <tt>-&gt;</tt> </td><td> ascSmall | uniSmall | <tt>_
</tt></td></tr><tr><td>
ascSmall </td><td>  <tt>-&gt;</tt> </td><td> <tt>a</tt> | <tt>b</tt> | ... | <tt>z
</tt></td></tr><tr><td>
uniSmall </td><td>  <tt>-&gt;</tt> </td><td> any Unicode lowercase letter
</td></tr><tr><td>
large </td><td>  <tt>-&gt;</tt> </td><td> ascLarge | uniLarge
</td></tr><tr><td>
ascLarge </td><td>  <tt>-&gt;</tt> </td><td> <tt>A</tt> | <tt>B</tt> | ... | <tt>Z
</tt></td></tr><tr><td>
uniLarge </td><td>  <tt>-&gt;</tt> </td><td> any uppercase or titlecase Unicode letter
</td></tr><tr><td>
symbol </td><td>  <tt>-&gt;</tt> </td><td> ascSymbol | uniSymbol<sub>&lt;special | <tt>_</tt> | <tt>:</tt> | <tt>"</tt> | <tt>'</tt>&gt;</sub>
</td></tr><tr><td>
ascSymbol </td><td>  <tt>-&gt;</tt> </td><td> <tt>!</tt> | <tt>#</tt> | <tt>$</tt> | <tt>%</tt> | <tt>&amp;</tt> | <tt>*</tt> | <tt>+</tt> | <tt>.</tt> | <tt>/</tt> | <tt>&lt;</tt> | <tt>=</tt> | <tt>&gt;</tt> | <tt>?</tt> | @
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>\</tt> | <tt>^</tt> | <tt>|</tt> | <tt>-</tt> | <tt>~
</tt></td></tr><tr><td>
uniSymbol </td><td>  <tt>-&gt;</tt> </td><td> any Unicode symbol or punctuation
</td></tr><tr><td>
digit </td><td>  <tt>-&gt;</tt> </td><td> ascDigit | uniDigit
</td></tr><tr><td>
ascDigit </td><td>  <tt>-&gt;</tt> </td><td> <tt>0</tt> | <tt>1</tt> | ... | <tt>9
</tt></td></tr><tr><td>
uniDigit </td><td>  <tt>-&gt;</tt> </td><td> any Unicode decimal digit
</td></tr><tr><td>
octit </td><td>  <tt>-&gt;</tt> </td><td> <tt>0</tt> | <tt>1</tt> | ... | <tt>7
</tt></td></tr><tr><td>
hexit </td><td>  <tt>-&gt;</tt> </td><td> digit | <tt>A</tt> | ... | <tt>F</tt> | <tt>a</tt> | ... | <tt>f
</tt></td></tr></table>
<p>
Lexical analysis should use the "maximal munch" rule:
at each point, the longest possible lexeme
satisfying the <I>lexeme</I> production is read.

So, although <tt>case</tt> is a reserved word, <tt>cases</tt> is not.
Similarly, although <tt>=</tt> is reserved, <tt>==</tt> and <tt>~=</tt> are
not.  <p>
Any kind of <I>whitespace</I> is also a proper delimiter for lexemes.<p>
Characters not in the category <I>ANY</I> are not valid
in Haskell  programs and should result in a lexing error.<p>
<a name="sect2.3"></a>
<h3>2.3<tt>&nbsp;&nbsp;</tt>Comments</h3><p>
Comments are valid whitespace.<p>
An ordinary comment begins with a sequence of
two or more consecutive dashes (e.g. <tt>--</tt>) and extends to the following newline.
<I>The sequence of dashes must not form part of a legal lexeme.
</I>For example, "<tt>--&gt;</tt>" or "<tt>|--</tt>" do <I>not</I> begin
a comment, because both of these are legal lexemes; however "<tt>--foo</tt>"
does start a comment.<p>
A nested comment begins with "<tt>{-</tt>" 
and ends with "<tt>-}</tt>".  No legal lexeme starts with "<tt>{-</tt>"; 
hence, for example, "<tt>{---</tt>" starts a nested comment despite the trailing dashes.<p>
The comment itself is not lexically analysed.  Instead, the first
unmatched occurrence of the string "<tt>-}</tt>" terminates the nested
comment.  Nested comments may be nested to any depth: any occurrence
of the string "<tt>{-</tt>" within the nested comment starts a new nested
comment, terminated by "<tt>-}</tt>".  Within a nested comment, each
"<tt>{-</tt>" is matched by a corresponding occurrence of "<tt>-}</tt>".<p>
In an ordinary comment, the character
sequences "<tt>{-</tt>" and "<tt>-}</tt>" have no special significance, and, in a
nested comment, a sequence of dashes has no special significance.<p>
Nested comments are also used for compiler pragmas, as explained in
Chapter <a href="pragmas.html#pragmas">11</a>.<p>
If some code is commented out using a nested comment, then any
occurrence of <tt>{-</tt> or <tt>-}</tt> within a string or within an end-of-line
comment in that code will interfere with the nested comments.<a name="ids"></a><p>
<a name="sect2.4"></a>
<h3>2.4<tt>&nbsp;&nbsp;</tt>Identifiers and Operators</h3>
<p>
<table cellspacing=0 cellspacing=0>
<tr><td width=100>
varid </td><td width=20>  <tt>-&gt;</tt> </td><td width=250> (small {small | large | digit | <tt>'</tt> })<sub>&lt;reservedid&gt;</sub>
</td></tr><tr><td>
conid </td><td>  <tt>-&gt;</tt> </td><td> large {small | large | digit | <tt>'</tt> }
</td></tr><tr><td>
reservedid </td><td>  <tt>-&gt;</tt> </td><td> <tt>case</tt> | <tt>class</tt> | <tt>data</tt> | <tt>default</tt> | <tt>deriving</tt> | <tt>do</tt> | <tt>else
</tt></td></tr><tr><td>
</td><td> <tt>|</tt> </td><td> <tt>if</tt> | <tt>import</tt> | <tt>in</tt> | <tt>infix</tt> | <tt>infixl</tt> | <tt>infixr</tt> | <tt>instance
</tt></td></tr><tr><td>
</td><td> <tt>|</tt> </td><td> <tt>let</tt> | <tt>module</tt> | <tt>newtype</tt> | <tt>of</tt> | <tt>then</tt> | <tt>type</tt> | <tt>where</tt> | <tt>_
</tt></td></tr></table>
<p>
An identifier consists of a letter followed by zero or more letters,
digits, underscores, and single quotes.  Identifiers are lexically
distinguished into two namespaces (Section <a href="intro.html#namespaces">1.4</a>): those that begin with a lower-case letter
(variable identifiers) and those that begin with an upper-case letter
(constructor identifiers).  Identifiers are case sensitive: <tt>name</tt>,
<tt>naMe</tt>, and <tt>Name</tt> are three distinct identifiers (the first two are
variable identifiers, the last is a constructor identifier).<p>
Underscore, "<tt>_</tt>", is treated as a lower-case letter, and can occur
wherever a lower-case letter can.  However, "<tt>_</tt>" all by itself is a
reserved identifier, used as wild card in patterns.  Compilers that offer
warnings for unused identifiers are encouraged to suppress such warnings for
identifiers beginning with underscore.  This allows programmers to use
"<tt>_foo</tt>" for a parameter that they expect to be unused.<p>
<table cellspacing=0 cellspacing=0>
<tr><td width=100>
varsym </td><td width=20>  <tt>-&gt;</tt> </td><td width=250> ( symbol {symbol | <tt>:</tt>})<sub>&lt;reservedop | dashes&gt;</sub>
</td></tr><tr><td>
consym </td><td>  <tt>-&gt;</tt> </td><td> (<tt>:</tt> {symbol | <tt>:</tt>})<sub>&lt;reservedop&gt;</sub>
</td></tr><tr><td>
reservedop </td><td>  <tt>-&gt;</tt> </td><td> <tt>..</tt> | <tt>:</tt> | <tt>::</tt> | <tt>=</tt> | <tt>\</tt> | <tt>|</tt> | <tt>&lt;-</tt> | <tt>-&gt;</tt> | <tt>@</tt> | <tt>~</tt> | <tt>=&gt;
</tt></td></tr></table>
<p>
<I>Operator symbols</I>  
are formed from one or more symbol characters, as
defined above, and are lexically distinguished into two namespaces 
(Section <a href="intro.html#namespaces">1.4</a>):
<UL><LI>An operator symbol starting with a colon is a constructor.
<LI>An operator symbol starting with any other character is an ordinary identifier.
</UL>
Notice that a colon by itself, "<tt>:</tt>", is reserved solely for use
as the Haskell list constructor; this makes its treatment uniform with
other parts of list syntax, such as "<tt>[]</tt>" and "<tt>[a,b]</tt>".<p>
Other than the special syntax for prefix negation, all operators are
infix, although each infix operator can be used in a 
<I>section</I> to yield partially applied operators (see
Section <a href="exps.html#sections">3.5</a>).
All of the standard infix operators are just
predefined symbols and may be rebound.  <p>
In the remainder of the report six different kinds of 
names will be used:<p>
<table cellspacing=0 cellspacing=0>
<tr><td width=100>
varid </td><td width=20> </td><td width=250></td><td> (variables)
</td></tr><tr><td>
conid </td><td> </td><td></td><td> (constructors)
</td></tr><tr><td>
tyvar </td><td>  <tt>-&gt;</tt> </td><td>  varid	</td><td> (type variables)
</td></tr><tr><td>
tycon </td><td>  <tt>-&gt;</tt> </td><td>  conid 	</td><td> (type constructors)
</td></tr><tr><td>
tycls </td><td>  <tt>-&gt;</tt> </td><td>  conid 	</td><td> (type classes)
</td></tr><tr><td>
modid </td><td>  <tt>-&gt;</tt> </td><td>  conid	</td><td> (modules)
</td></tr></table>
<p>
Variables and type variables are represented by identifiers beginning
with small letters, and the other four by identifiers beginning with
capitals; also, variables and constructors have infix forms, the other
four do not.  Namespaces are also discussed in
Section <a href="intro.html#namespaces">1.4</a>.<p>

A name may optionally be <I>qualified</I> in certain
circumstances by prepending them with a module identifier.  This
applies to variable, constructor, type constructor and type class
names, but not type variables or module names.  Qualified
names are discussed in detail in Chapter <a href="modules.html#modules">5</a>.
<table cellspacing=0 cellspacing=0>
<tr><td width=100>
qvarid </td><td width=20>  <tt>-&gt;</tt> </td><td width=250> [modid <tt>.</tt>] varid
</td></tr><tr><td>
qconid </td><td>  <tt>-&gt;</tt> </td><td> [modid <tt>.</tt>] conid
</td></tr><tr><td>
qtycon </td><td>  <tt>-&gt;</tt> </td><td> [modid <tt>.</tt>] tycon
</td></tr><tr><td>
qtycls </td><td>  <tt>-&gt;</tt> </td><td> [modid <tt>.</tt>] tycls
</td></tr><tr><td>
qvarsym </td><td>  <tt>-&gt;</tt> </td><td> [modid <tt>.</tt>] varsym
</td></tr><tr><td>
qconsym </td><td>  <tt>-&gt;</tt> </td><td> [modid <tt>.</tt>] consym
</td></tr></table>
Since a qualified name is a lexeme, no spaces are
allowed between the qualifier and the name.
Sample lexical analyses are shown below.
<p>
<table border=2>
<tr><td>

This                       	    </td><td> Lexes as this                       </td></tr><tr><td>
<tt>f.g</tt>                               </td><td> <tt>f&nbsp;.&nbsp;g</tt> (three tokens)             </td></tr><tr><td><tt>F.g</tt>		                    </td><td> <tt>F.g</tt> (qualified `g')            </td></tr><tr><td><tt>f..</tt>		                    </td><td> <tt>f&nbsp;..</tt> (two tokens)    </td></tr><tr><td><tt>F..</tt>	                            </td><td> <tt>F..</tt> (qualified `.')	    </td></tr><tr><td><tt>F.</tt>                                </td><td> <tt>F&nbsp;.</tt> (two tokens)                     </td></tr></table>
<p>

The qualifier does not change the syntactic treatment of a name;
for example, <tt>Prelude.+</tt> is an infix operator with the same fixity as the 
definition of <tt>+</tt> in the Prelude (Section <a href="decls.html#fixity">4.4.2</a>).<a name="lexemes-numeric"></a><p>
<a name="sect2.5"></a>
<h3>2.5<tt>&nbsp;&nbsp;</tt>Numeric Literals</h3>
<p>
<table cellspacing=0 cellspacing=0>
<tr><td width=100>
decimal </td><td width=20>  <tt>-&gt;</tt> </td><td width=250> digit{digit}
</td></tr><tr><td>
octal </td><td>  <tt>-&gt;</tt> </td><td> octit{octit}
</td></tr><tr><td>
hexadecimal </td><td>  <tt>-&gt;</tt> </td><td> hexit{hexit}
</td></tr></table>
<table cellspacing=0 cellspacing=0>
<tr><td width=100></td><td width=20></td><td width=250></td></tr><tr></tr><tr><td>
integer </td><td>  <tt>-&gt;</tt> </td><td> decimal
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>0o</tt> octal | <tt>0O</tt> octal
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  <tt>0x</tt> hexadecimal | <tt>0X</tt> hexadecimal
</td></tr><tr><td>
float </td><td>  <tt>-&gt;</tt> </td><td> decimal <tt>.</tt> decimal [exponent]
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td>  decimal exponent
</td></tr><tr><td>
exponent </td><td>  <tt>-&gt;</tt> </td><td> (<tt>e</tt> | <tt>E</tt>) [<tt>+</tt> | <tt>-</tt>] decimal
</td></tr></table>
There are two distinct kinds of numeric literals: integer and
floating.  Integer literals may be given in decimal (the default),
octal (prefixed by <tt>0o</tt> or <tt>0O</tt>) or hexadecimal notation (prefixed by
<tt>0x</tt> or <tt>0X</tt>).
Floating literals are always decimal.
A floating literal must contain digits both before and after the
decimal point; this ensures that a decimal point cannot be mistaken
for another use of the dot character.  Negative numeric literals are
discussed in Section <a href="exps.html#operators">3.4</a>.  The typing of numeric literals
is discussed in Section <a href="basic.html#numeric-literals">6.4.1</a>.<a name="lexemes-char"></a><p>
<a name="sect2.6"></a>
<h3>2.6<tt>&nbsp;&nbsp;</tt>Character and String Literals</h3>


<p>
<table cellspacing=0 cellspacing=0>
<tr><td width=100>
char </td><td width=20>  <tt>-&gt;</tt> </td><td width=250>  <tt>'</tt> (graphic<sub>&lt;<tt>'</tt> | <tt>\</tt>&gt;</sub> | space | escape<sub>&lt;<tt>\&amp;</tt>&gt;</sub>) <tt>'
</tt></td></tr><tr><td>
string </td><td>  <tt>-&gt;</tt> </td><td>  <tt>"</tt> {graphic<sub>&lt;<tt>"</tt>  | <tt>\</tt>&gt;</sub> | space | escape | gap}<tt>"
</tt></td></tr><tr><td>
escape </td><td>  <tt>-&gt;</tt> </td><td>  <tt>\</tt> ( charesc | ascii | decimal | <tt>o</tt> octal | <tt>x</tt> hexadecimal )
</td></tr><tr><td>
charesc </td><td>  <tt>-&gt;</tt> </td><td> <tt>a</tt> | <tt>b</tt> | <tt>f</tt> | <tt>n</tt> | <tt>r</tt> | <tt>t</tt> | <tt>v</tt> | <tt>\</tt> | <tt>"</tt> | <tt>'</tt> | <tt>&amp;
</tt></td></tr><tr><td>
ascii </td><td>  <tt>-&gt;</tt> </td><td> <tt>^</tt>cntrl | <tt>NUL</tt> | <tt>SOH</tt> | <tt>STX</tt> | <tt>ETX</tt> | <tt>EOT</tt> | <tt>ENQ</tt> | <tt>ACK</tt> 
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td> <tt>BEL</tt> | <tt>BS</tt> | <tt>HT</tt> | <tt>LF</tt> | <tt>VT</tt> | <tt>FF</tt> | <tt>CR</tt> | <tt>SO</tt> | <tt>SI</tt> | <tt>DLE</tt> 
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td> <tt>DC1</tt> | <tt>DC2</tt> | <tt>DC3</tt> | <tt>DC4</tt> | <tt>NAK</tt> | <tt>SYN</tt> | <tt>ETB</tt> | <tt>CAN</tt> 
</td></tr><tr><td>
</td><td> <tt>|</tt> </td><td> <tt>EM</tt> | <tt>SUB</tt> | <tt>ESC</tt> | <tt>FS</tt> | <tt>GS</tt> | <tt>RS</tt> | <tt>US</tt> | <tt>SP</tt> | <tt>DEL
</tt></td></tr><tr><td>
cntrl </td><td>  <tt>-&gt;</tt> </td><td> ascLarge | @ | <tt>[</tt> | <tt>\</tt> | <tt>]</tt> | <tt>^</tt> | <tt>_
</tt></td></tr><tr><td>
gap </td><td>  <tt>-&gt;</tt> </td><td>  <tt>\</tt> whitechar {whitechar}<tt>\
</tt></td></tr></table>
<p>
Character literals are written between single quotes, as in
<tt>'a'</tt>, and strings between double quotes, as in <tt>"Hello"</tt>.<p>
Escape codes may be used in characters and strings to represent
special characters.  Note that a single quote <tt>'</tt> may be used in a string, but
must be escaped in a character; similarly, a double quote <tt>"</tt> may be used in a
character, but must be escaped in a string.  <tt>\</tt> must always be
escaped.  The category <I>charesc</I> also includes portable
representations for the characters "alert" (<tt>\a</tt>), "backspace"
(<tt>\b</tt>), "form feed" (<tt>\f</tt>), "new line" (<tt>\n</tt>), "carriage return"
(<tt>\r</tt>), "horizontal tab" (<tt>\t</tt>), and "vertical tab" (<tt>\v</tt>).<p>
Escape characters for the Unicode character
set, including
control characters such as <tt>\^X</tt>, are also provided.
Numeric escapes such as <tt>\137</tt> are used to designate the character
with decimal representation 137; octal
(e.g. <tt>\o137</tt>) and hexadecimal (e.g. <tt>\x37</tt>) representations are also
allowed.  <p>
Consistent with the "maximal munch" rule,

numeric escape
characters in strings consist of all consecutive digits and may
be of arbitrary length.  Similarly, the one ambiguous ASCII escape
code, <tt>"\SOH"</tt>, is parsed as a string of length 1.  The escape
character <tt>\&amp;</tt> is provided as a "null character" to allow strings
such as <tt>"\137\&amp;9"</tt> and <tt>"\SO\&amp;H"</tt> to be constructed (both of length
two).  Thus <tt>"\&amp;"</tt> is equivalent to <tt>""</tt> and the character
<tt>'\&amp;'</tt> is disallowed.  Further equivalences of characters
are defined in Section <a href="basic.html#characters">6.1.2</a>.<p>
A string may include a "gap"---two backslants enclosing
white characters---which is ignored.
This allows one to write long strings on more than one line by writing
a backslant at the end of one line and at the start of the next.  For
example,
<tt><br>

<br>
"Here&nbsp;is&nbsp;a&nbsp;backslant&nbsp;\\&nbsp;as&nbsp;well&nbsp;as&nbsp;\137,&nbsp;\<br>
&nbsp;&nbsp;&nbsp;&nbsp;\a&nbsp;numeric&nbsp;escape&nbsp;character,&nbsp;and&nbsp;\^X,&nbsp;a&nbsp;control&nbsp;character."<br>
<p>
</tt>String literals are actually abbreviations for lists of characters
(see Section <a href="exps.html#lists">3.7</a>).<a name="lexemes-layout"></a><p>
<a name="sect2.7"></a>
<h3>2.7<tt>&nbsp;&nbsp;</tt>Layout</h3>
<p>
Haskell  permits the omission of the braces and semicolons used in several
grammar productions, by
using <I>layout</I> to convey the same information.  This allows both
layout-sensitive and layout-insensitive styles of coding, which
can be freely mixed within one program.  Because layout is
not required, Haskell  programs can be straightforwardly
produced by other programs.<p>
The effect of layout on the meaning of a Haskell program
can be completely specified by adding
braces and semicolons in places determined by the layout.  The meaning of
this augmented program is now layout insensitive.<p>
Informally stated, the braces and semicolons are inserted as follows.
The layout (or "off-side") rule takes effect
whenever the open brace is omitted after the keyword <tt>where</tt>, <tt>let</tt>,
<tt>do</tt>, or
<tt>of</tt>.  When this happens, the indentation of the next lexeme (whether
or not on a new line) is remembered and the omitted open brace is
inserted (the whitespace preceding the lexeme may include comments).
For each subsequent line, if it contains only whitespace or is
indented more, then the previous item is continued (nothing is
inserted); if it is indented the same amount, then a new item begins
(a semicolon is inserted); and if it is indented less, then the
layout list ends (a close brace is inserted).  If the indentation of the 
non-brace lexeme immediately following a <tt>where</tt>, <tt>let</tt>, <tt>do</tt> or <tt>of</tt> is less 
than or equal to the current indentation level, then instead of starting 
a layout, an empty list "<tt>{}</tt>" is inserted, and layout processing 
occurs for the current level (i.e. insert a semicolon or close brace). 
A close brace is
also inserted whenever the syntactic category containing the
layout list ends; that is, if an illegal lexeme is encountered at
a point where a close brace would be legal, a close brace is inserted.
The layout rule matches only those open braces that it has
inserted; an explicit open brace must be matched by
an explicit close brace.  Within these explicit open braces,
<I>no</I> layout processing is performed for constructs outside the
braces, even if a line is 
indented to the left of an earlier implicit open brace.<p>
Section <a href="syntax-iso.html#layout">9.3</a> gives a more precise definition of the layout rules.<p>
Given these rules, a single newline may actually terminate several
layout lists.  Also, these rules permit:
<tt><br>

<br>
f&nbsp;x&nbsp;=&nbsp;let&nbsp;a&nbsp;=&nbsp;1;&nbsp;b&nbsp;=&nbsp;2&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g&nbsp;y&nbsp;=&nbsp;exp2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in&nbsp;exp1<br>

<br>

</tt>making <tt>a</tt>, <tt>b</tt> and <tt>g</tt> all part of the same layout
list.<p>
As an example, Figure <a href="lexemes.html#layout-before">2.1</a> shows a (somewhat contrived)
module and Figure <a href="lexemes.html#layout-after">2.2</a> shows the result of applying the
layout rule to it.  Note in particular: (a) the line beginning <tt>}};pop</tt>,
where the termination of the previous line invokes three applications
of the layout rule, corresponding to the depth (3) of the nested
<tt>where</tt> clauses, (b) the close braces in the <tt>where</tt> clause nested
within the tuple and <tt>case</tt> expression, inserted because the end of the
tuple was detected, and (c) the close brace at the very end, inserted
because of the column 0 indentation of the end-of-file token.<p>
<table border=2 cellpadding=3>
<tr><td><div align=center><table border=2 cellpadding=3>
<tr><td>
<tt><br>
module&nbsp;AStack(&nbsp;Stack,&nbsp;push,&nbsp;pop,&nbsp;top,&nbsp;size&nbsp;)&nbsp;where<br>
data&nbsp;Stack&nbsp;a&nbsp;=&nbsp;Empty&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;MkStack&nbsp;a&nbsp;(Stack&nbsp;a)<br>
<br>
push&nbsp;::&nbsp;a&nbsp;-&gt;&nbsp;Stack&nbsp;a&nbsp;-&gt;&nbsp;Stack&nbsp;a<br>
push&nbsp;x&nbsp;s&nbsp;=&nbsp;MkStack&nbsp;x&nbsp;s<br>
<br>
size&nbsp;::&nbsp;Stack&nbsp;a&nbsp;-&gt;&nbsp;Int<br>
size&nbsp;s&nbsp;=&nbsp;length&nbsp;(stkToLst&nbsp;s)&nbsp;&nbsp;where<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stkToLst&nbsp;&nbsp;Empty&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;[]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stkToLst&nbsp;(MkStack&nbsp;x&nbsp;s)&nbsp;&nbsp;=&nbsp;x:xs&nbsp;where&nbsp;xs&nbsp;=&nbsp;stkToLst&nbsp;s<br>
<br>
pop&nbsp;::&nbsp;Stack&nbsp;a&nbsp;-&gt;&nbsp;(a,&nbsp;Stack&nbsp;a)<br>
pop&nbsp;(MkStack&nbsp;x&nbsp;s)<br>
&nbsp;&nbsp;=&nbsp;(x,&nbsp;case&nbsp;s&nbsp;of&nbsp;r&nbsp;-&gt;&nbsp;i&nbsp;r&nbsp;where&nbsp;i&nbsp;x&nbsp;=&nbsp;x)&nbsp;--&nbsp;(pop&nbsp;Empty)&nbsp;is&nbsp;an&nbsp;error<br>
<br>
top&nbsp;::&nbsp;Stack&nbsp;a&nbsp;-&gt;&nbsp;a<br>
top&nbsp;(MkStack&nbsp;x&nbsp;s)&nbsp;=&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;(top&nbsp;Empty)&nbsp;is&nbsp;an&nbsp;error<br>

</tt></td></tr></table>
</div>
<div align=center> <h4>Figure 1</h4> </div>
<div align=center><h3>A sample program</h3></div><a name="layout-before"></a>

<div align=center><table border=2 cellpadding=3>
<tr><td>
<tt><br>
module&nbsp;AStack(&nbsp;Stack,&nbsp;push,&nbsp;pop,&nbsp;top,&nbsp;size&nbsp;)&nbsp;where<br>
{data&nbsp;Stack&nbsp;a&nbsp;=&nbsp;Empty&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;MkStack&nbsp;a&nbsp;(Stack&nbsp;a)<br>
<br>
;push&nbsp;::&nbsp;a&nbsp;-&gt;&nbsp;Stack&nbsp;a&nbsp;-&gt;&nbsp;Stack&nbsp;a<br>
;push&nbsp;x&nbsp;s&nbsp;=&nbsp;MkStack&nbsp;x&nbsp;s<br>
<br>
;size&nbsp;::&nbsp;Stack&nbsp;a&nbsp;-&gt;&nbsp;Int<br>
;size&nbsp;s&nbsp;=&nbsp;length&nbsp;(stkToLst&nbsp;s)&nbsp;&nbsp;where<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{stkToLst&nbsp;&nbsp;Empty&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;[]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;stkToLst&nbsp;(MkStack&nbsp;x&nbsp;s)&nbsp;&nbsp;=&nbsp;x:xs&nbsp;where&nbsp;{xs&nbsp;=&nbsp;stkToLst&nbsp;s<br>
<br>
}};pop&nbsp;::&nbsp;Stack&nbsp;a&nbsp;-&gt;&nbsp;(a,&nbsp;Stack&nbsp;a)<br>
;pop&nbsp;(MkStack&nbsp;x&nbsp;s)<br>
&nbsp;&nbsp;=&nbsp;(x,&nbsp;case&nbsp;s&nbsp;of&nbsp;{r&nbsp;-&gt;&nbsp;i&nbsp;r&nbsp;where&nbsp;{i&nbsp;x&nbsp;=&nbsp;x}})&nbsp;--&nbsp;(pop&nbsp;Empty)&nbsp;is&nbsp;an&nbsp;error<br>
<br>
;top&nbsp;::&nbsp;Stack&nbsp;a&nbsp;-&gt;&nbsp;a<br>
;top&nbsp;(MkStack&nbsp;x&nbsp;s)&nbsp;=&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;(top&nbsp;Empty)&nbsp;is&nbsp;an&nbsp;error<br>
}<br>

</tt></td></tr></table>
</div>
<div align=center> <h4>Figure 2</h4> </div>
<div align=center><h3>Sample program with layout expanded</h3></div><a name="layout-after"></a>
<p>
</td></tr></table>
<p>
<hr><i>The Haskell 98 Report</i><br><a href="index.html">top</a> | <a href="intro.html">back</a> | <a href="exps.html">next</a> | <a href="index98.html">contents</a> | <a href="prelude-index.html">function index</a> <br><font size=2>December 2002</font>
<p>
