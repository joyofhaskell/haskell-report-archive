%
% $Header: /tmp_mnt/local.fp/haskell/report/report-1.0/RCS/syntax.verb,v 1.0 90/03/28 15:00:09 partain Exp $
%
\section{Syntax}
\label{syntax}
\index{syntax}

\subsection{Notational Conventions}

These notational conventions are used for presenting syntax:

\[\ba{cl}
"[pattern]"		& \tr{optional} \\
"\{pattern\}"		& \tr{zero or more repetitions} \\
"(pattern)"		& \tr{grouping} \\
"pat_1 | pat_2"		& \tr{choice} \\
"pat_{\{pat'\}}"	& \tr{difference---elements generated by "pat"} \\
			& \tr{except those generated by "pat'"} \\
"@fibonacci@"		& \tr{terminal syntax in typewriter font}
\ea\]

BNF-like syntax is used throughout, with productions having form:
@@@
nonterm		-> alt_1 | alt_2 | ... | alt_n
@@@

\subsection{Lexical Syntax}

@@@
program		-> \{ lexeme | whitespace \}
lexeme          -> varid | conid | varop | conop | literal | special | reservedop | reservedid
literal		-> integer | float | char | string
special		-> @(@ | @)@ | @,@ | @;@ | @[@ | @]@ | @_@ | @{@ | @}@

whitespace	-> whitestuff \{whitestuff\}
whitestuff -> newline | space | tab | vertab | formfeed | comment | ncomment
newline		-> \tr{a newline (system dependent)}
space		-> \tr{a space}
tab		-> \tr{a horizontal tab}
vertab		-> \tr{a vertical tab}
formfeed	-> \tr{a form feed}
comment		-> @--@ \{any\} newline
ncomment	-> @{-@ \{whitespace | any_{\{@{-@ | @-}@\}} \} @-}@
any		-> graphic | space | tab
graphic		-> large | small | digit
 | @!@ | @"@ | @#@ | @$@ | @%@ | @&@  | \fwq | @(@ | @)@ | @*@ | @+@
 | @,@ | @-@ | @.@ | @/@ | @:@ | @;@  | @<@  | @=@ | @>@ | @?@ | @@
 | @[@ | @\@ | @]@ | @^@ | @_@ | \bkq | @{@  | @|@ | @}@ | @~@
small		-> @a@ | @b@ | ... | @z@
large		-> @A@ | @B@ | ... | @Z@
digit		-> @0@ | @1@ | ... | @9@
@@@

@@@
avarid	-> (small \{small | large | digit | \fwq | @_@\})_{\{reservedid\}}
varid		-> avarid | @(@avarop@)@
aconid		-> large \{small | large | digit | \fwq | @_@\} 
conid		-> aconid | @(@aconop@)@
reservedid -> @case@ | @class@ | @data@ | @default@ | @deriving@ | @else@ | @hiding@
	| @if@ | @import@ | @infix@ | @infixl@ | @infixr@ | @instance@ | @interface@
	| @module@ | @of@ | @renaming@ | @then@ | @to@ | @type@ | @where@
@@@

@@@
avarop		-> ( symbol \{symbol | @:@\} )_{\{reservedop\}} | @-@
varop		-> avarop | \bkqB{avarid}\bkqA
aconop		-> (@:@ \{symbol | @:@\})_{\{reservedop\}}
conop		-> aconop | \bkqB{aconid}\bkqA
symbol		-> @!@ | @#@ | @$@ | @%@ | @&@ | @*@ | @+@ | @.@ | @/@ | @<@ | @=@ | @>@ | @?@ | @@ | @\@ | @^@ | @|@ | @~@ 
reservedop	-> @..@ | @::@ | @=>@ | @=@ | @@ | @\@ | @|@ | @~@
@@@

@@@
var	->  varid	& (variables)
con	->  conid 	& (constructors)
tyvar	->  avarid	& (type variables)
tycon	->  aconid	& (type constructors)
tycls	->  aconid	& (type classes)
modid   ->  aconid	& (modules)
@@@

@@@
integer		-> digit\{digit\}
float		-> integer@.@integer[@e@[@-@]integer]
@@@

@@@
char    ->  \fwq (graphic_{\{\fwq | @\@\}} | space | escape_{\{@\&@\}}) \fwq
string  ->  @"@ \{graphic_{\{@"@  | @\@\}} | space | escape | gap\} @"@
escape  ->  @\@ ( charesc | ascii | integer | @o@ octit\{octit\} | @x@ hexit\{hexit\} )
charesc -> @a@ | @b@ | @f@ | @n@ | @r@ | @t@ | @v@ | @\@ | @"@ | \fwq | @&@
ascii   -> @^@cntrl | @NUL@ | @SOH@ | @STX@ | @ETX@ | @EOT@ | @ENQ@ | @ACK@ 
       | @BEL@ | @BS@ | @HT@ | @LF@ | @VT@ | @FF@ | @CR@ | @SO@ | @SI@ | @DLE@ 
       | @DC1@ | @DC2@ | @DC3@ | @DC4@ | @NAK@ | @SYN@ | @ETB@ | @CAN@ 
       | @EM@ | @SUB@ | @ESC@ | @FS@ | @GS@ | @RS@ | @US@ | @SP@ | @DEL@
cntrl   -> large | @@ | @[@ | @\@ | @]@ | @^@ | @_@
gap     ->  @\@ \{tab | space\} newline \{tab | space\} @\@
hexit   -> digit | @A@ | @B@ | @C@ | @D@ | @E@ | @F@ | @a@ | @b@ | @c@ | @d@ | @e@ | @f@
octit   -> @0@ | @1@ | @2@ | @3@ | @4@ | @5@ | @6@ | @7@
@@@

\subsection{Layout}
\label{layout}
\index{layout}

Definitions: The indentation of a lexeme is the column number
indicating the start of that lexeme; the indentation of a line is the
indentation of its left-most lexeme.  To determine the column number,
assume a fixed-width font with this tab convention: tab stops
are 8 characters apart, and a tab character causes the insertion of
enough spaces to align the current position with the next tab stop.

In the syntax given in the other parts of the report, {\em declaration
lists} are always preceded by the keyword @where@ or @of@, and are
enclosed within curly braces (@{ }@) with the individual declarations
separated by semicolons (@;@).  For example, the syntax of a @where@
expression is:
\[
"exp @where@ @{@ decl_1 @;@ decl_2 @;@ ... @;@ decl_n @}@"
\]

\input{layout}

\subsection{Context-Free Syntax}
\label{bnf}

@@@ 
module -> @module@ modid [exports] @where@ body
       |  body
body   -> @{@ [impdecls @;@] [fixdecls @;@] topdecls @}@
       |  @{@ impdecls @}@

modid	     -> aconid
impdecls     -> impdecl_1 @;@ ... @;@ impdecl_n	& \qquad (n>=1)
@@@ 

@@@
exports	     -> @(@ export_1 @,@ ... @,@ export_n @)@ & \qquad (n>=1)
export   -> varid
         |  tycon
	 |  tycon @(..)@
         |  tycon @(@ conid_1 @,@ ... @,@ conid_n @)@	& \qquad (n>=1)
	 |  tycls @(..)@
	 |  tycls @(@ varid_1 @,@ ... @,@ varid_n @)@	& \qquad (n>=0)
         |  modid @..@
@@@

@@@
impdecl   -> @import@ modid [impspec] [@renaming@ renamings] 
impspec   -> @(@ import_1 @,@ ... @,@ import_n @)@ & \qquad (n>=0)
             |  @hiding@ @(@ import_1 @,@ ... @,@ import_n @)@ & \qquad (n>=1)
import   -> varid 
         |  tycon
	 |  tycon @(..)@
         |  tycon @(@ conid_1 @,@ ... @,@ conid_n @)@	& \qquad (n>=1)
	 |  tycls @(..)@
	 |  tycls @(@ varid_1 @,@ ... @,@ varid_n @)@	& \qquad (n>=0)
renamings -> @(@ renaming_1 @,@ ... @,@ renaming_n @)@	& \qquad (n>=1)
renaming -> name_1 @to@ name_2
name     -> varid | conid
@@@

@@@
fixdecls -> fix_1 @;@ ... @;@ fix_n		& \qquad (n>=1)
fix	-> @infixl@ [digit] ops 
 	 | @infixr@ [digit] ops
  	 | @infix @ [digit] ops 
ops	-> op_1 @,@ ... @,@ op_n		& \qquad (n>=1)
op	-> varop | conop 
@@@

@@@
topdecls-> topdecl_1 @;@ ... @;@ topdecl_n	& \qquad (n>=1)
topdecl	-> @type@ [context @=>@] simple @=@ type
	| @data@ [context @=>@] simple @=@ constrs [@deriving@ (tycls | @(@tyclses@)@)]
	| @class@ [context @=>@] class [@where@ @{@ cdecls @}@]
	| @instance@ [context @=>@] tycls inst [@where@ @{@ decls @}@]
	| @default@ (type | @(@type_1 @,@ ... @,@ type_n@)@) & \qquad (n>=0)
	| decl

decls	-> decl_1 @;@ ... @;@ decl_n		& \qquad (n>=1)
decl	-> vars @::@ [context @=>@] type	
	|  valdef
@@@

@@@
type	->  atype				
	|   type_1 @->@ type_2
	|   tycon atype_1 ... atype_k		& (\arity{tycon}=k>=1) 

atype	->  tyvar				
	|   tycon				& (\arity{tycon}=0) 
	|   @()@				& (\tr{unit type})
	|   @(@ type @)@			& (\tr{parenthesised type})
	|   @(@ type_1 @,@ ... @,@ type_k @)@	& (\tr{tuple type}, k>=2)
	|   @[@ type @]@			
@@@

@@@
context -> class 
        |  @(@ class_1 @,@ ... @,@ class_n @)@		& (n>=1)
class	-> tycls tyvar			

cdecls	-> cdecl_1 @;@ ... @;@ cdecl_n	& (n>=1)
cdecl	-> vars @::@ type
        |  valdef

vars	->  var_1 @,@ ...@,@ var_n			& (n>=1)
@@@

@@@
simple	->  tycon tyvar_1 ... tyvar_k		& (\arity{tycon}=k>=0) 
constrs	-> constr_1 @|@ ... @|@ constr_n	& (n>=1)
constr	-> con atype_1 ... atype_k		& (\arity{con}=k>=0)
	|  type_1 conop type_2			& (\infix{conop})
tyclses -> tycls_1@,@ ...@,@ tycls_n		& (n>=0)
@@@

@@@
inst	-> tycon				& (\arity{tycon}=0)
	|  @(@ tycon tyvar_1 ... tyvar_k @)@	& (\arity{tycon}=k>0)
	|  @(@ tyvar_1 @,@ ... @,@ tyvar_k @)@	& k>=2
        |  @()@
	|  @[@ tyvar @]@
        |  tyvar_1 @->@ tyvar_2
@@@

@@@
valdef	->  lhs @=@ exp
	|   lhs gdfun

lhs	->  pat
        |   var apat_1 ... apat_k      		              & (k>=1)
	|   apat_1 varop apat_2
	|   @(@ apat_1 varop apat_2 @)@ apat_3 ... apat_k     & (k>=3)

gdfun	->  gd @=@ exp [gdfun]

gd	->  @|@ exp 
@@@

@@@
exp	->  aexp				
	|   exp aexp				& (\tr{function application})
	|   exp_1 op exp_2			& (\tr{operator application})
	|   @-@ aexp				& (\prefix{@-@}) 
        | @\@ apat_1 ... apat_n [gd] @->@ exp & (\tr{lambda abstraction}, n>=1)
	|   @if@ exp_1 @then@ exp_2 @else@ exp_3 & (\tr{conditional})
	|   exp @where@ @{@ decls @}@           & (\tr{where expression})
	|  @case@ exp @of@ @{@ alts @}@         & (\tr{case expression})
        |   exp @::@ [context @=>@] atype  & (\tr{expression type signature})

aexp	->  var				        & (\tr{variable})
	|   con					& (\tr{constructor})
	|   literal				
        |   @()@                                & (\tr{unit})
        |   @(@ exp @)@                       & (\tr{parenthesised expression})
	|   @(@ exp_1 @,@ ... @,@ exp_k @)@	& (\tr{tuple}, k>=2)
	|   @[@ exp_1 @,@ ... @,@ exp_k @]@	& (\tr{list}, k>=0)
	|   @[@ exp_1 [@,@ exp_2] @..@ [exp_3] @]@ & (\tr{arithmetic sequence})
	|   @[@ exp @|@ [qual] @]@		& (\tr{list comprehension})
@@@

@@@
qual	-> qual_1 @,@ qual_2 
         | pat @<-@ exp 
         | exp 

alts	->  alt_1 @;@ ... @;@ alt_n		& (n>=1)
alt	->  pat [gd] @->@ exp
@@@

@@@
pat -> apat
	|   con apat_1 ... apat_k		& (\arity{con}=k>=1)
	|   pat_1 conop pat_2                   & (\tr{infix constructor})
	|   var @+@ integer			& (\tr{successor pattern})
        |   [ @-@ ] integer                       

apat -> var [{\tt @@}  apat]				& (\tr{as pattern})
	|   con					& (\arity{con}=0) 
	|   integer | float | char | string 	& (\tr{literals})
	|   @_@					& (\tr{wildcard})
	|   @(@ pat_1 @,@ ... @,@ pat_k @)@	& (\tr{tuple patterns}, k>=2)
	|   @[@ pat_1 @,@ ... @,@ pat_k @]@	& (\tr{list patterns}, k>=0) 
        |   @(@ pat @)@                        & (\tr{parenthesised pattern})
        |   @()@                                & (\tr{unit pattern})
	|   @~@ apat
@@@

@@@
tycls	->  aconid
tyvar	->  avarid
tycon	->  aconid
@@@

\subsection{Interface Syntax}
\label{ibnf}

@@@
interface -> @interface@ modid @where@ ibody
ibody -> @{@ [iimpdecls @;@] [fixes @;@] itopdecls @}@
      | @{@ iimpdecls @}@
iimpdecls -> iimpdecl_1 @;@ ... @;@ iimpdecl_n	& \qquad (n>=1) 
iimpdecl   -> @import@ modid @(@ import_1 @,@ ... @,@ import_n @)@ 
	& [@renaming@ renamings] & \qquad (n>=1)
itopdecls -> itopdecl_1 @;@ ... @;@ itopdecl_n	& \qquad (n>=1) 
itopdecl  -> @type@ [context @=>@] simple @=@ type
	| @data@ [context @=>@] simple [@=@ constrs] [@deriving@ (tycls | @(@tyclses@)@)]
	| @class@ [context @=>@] class [@where@ @{@ icdecls @}@]
     	| @instance@ [context @=>@] tycls inst
     	| vars @::@ [context @=>@] type
icdecls	-> icdecl_1 @;@ ... @;@ icdecl_n	& (n>=1)
icdecl	-> vars @::@ type
@@@

% Local Variables: 
% mode: latex
% End:
