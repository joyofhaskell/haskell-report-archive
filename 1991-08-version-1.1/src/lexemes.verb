%
% $Header$
%
\section{Lexical Structure}\index{lexical structure}
\label{lexical-structure}

% this quote is not in because: it is supposed to show Curry as an
% early advocate of abstract syntax.  However, as far as I know (which
% I can't be sure w/out going to the library), this quote is from 1972
% (when Vol II was published ?), which isn't particularly early.  This
% doesn't seem the sort of thing to get wrong!  If someone wants to do
% the checking and put it in (and re-BibTeX and re-check the page
% breaks :-), please feel free.

%% \begin{quote}
%% ``{\em The various systems of combinatory logic are presented in this
%% book as abstract obs systems.  It was mentioned in \S{}~1 that any
%% such system can be represented as a concrete syntactical system, and
%% that this can be done mechanically.  Nevertheless it seems expedient
%% to give such a representation explicitly for two reasons: in the first
%% place there is at present an almost universal insistence on such a
%% representation; in the second place the discussion of certain
%% philosophical questions is made somewhat easier by having a specific
%% representation before us.}''
%% \begin{flushright}
%% Haskell B.~Curry {\em et al.}\\
%% in {\em Combinatory Logic}, Vol.~II, page 8 \cite{curry-etal:volII}.
%% \end{flushright}
%% \end{quote}

\noindent
In this section, 
we describe the low-level lexical structure of \Haskell{}.
Most of the details may be skipped in a first reading of
the report.

\subsection{Notational Conventions}
\label{notational-conventions}

These notational conventions are used for presenting syntax:

\[\ba{cl}
"[pattern]"		& \tr{optional} \\
"\{pattern\}"		& \tr{zero or more repetitions} \\
"(pattern)"		& \tr{grouping} \\
"pat_1 | pat_2"		& \tr{choice} \\
"pat_{\{pat'\}}"	& \tr{difference---elements generated by "pat"} \\
			& \tr{except those generated by "pat'"} \\
"@fibonacci@"		& \tr{terminal syntax in typewriter font}
\ea\]

Because the syntax in this section describes {\em lexical} syntax, all
whitespace is expressed explicitly; there is no
implicit space between juxtaposed symbols.  BNF-like syntax is used
throughout, with productions having the form:
@@@
nonterm		-> alt_1 | alt_2 | ... | alt_n
@@@

There are some families of nonterminals indexed by
precedence levels (written as a superscript).  Similarly, the
lexeme classes "op", "varop", and "conop" have a double index:  a letter "l",
"r", or "n" for left-, right- or nonassociativity and a precedence
level.  So, for example
@@@
exp^i	->   exp^{i+1} [op^{({\rm n},i)} exp^{i+1}]	&	(0<=i<=9)
@@@
actually stands for 10~productions where "op" is non-associative.
Refer to Section~\ref{fixity} for information on fixity declarations.

Care must be taken in distinguishing metalogical syntax such as "|"
and "[...]" from concrete terminal syntax (given in typewriter font)
such as @|@ and @[...]@, although usually the context makes the
distinction clear.

\Haskell{} source programs are currently biased toward the ASCII
\index{ASCII character set}
character set, although future \Haskell{} standardisation efforts will
likely address broader character standards.

\subsection{Lexical Program Structure}
\label{lexemes}
\label{whitespace}

@@@
program		-> \{ lexeme | whitespace \}
lexeme          -> varid | conid | varop | conop | literal | special | reservedop | reservedid
literal		-> integer | float | char | string
special		-> @(@ | @)@ | @,@ | @;@ | @[@ | @]@ | @_@ | @{@ | @}@

whitespace	-> whitestuff \{whitestuff\}
whitestuff	-> whitechar | comment | ncomment
whitechar	-> newline | space | tab | vertab | formfeed
newline		-> \tr{a newline (system dependent)}
space		-> \tr{a space}
tab		-> \tr{a horizontal tab}
vertab		-> \tr{a vertical tab}
formfeed	-> \tr{a form feed}
comment		-> @--@ \{any\} newline
ncomment	-> @{-@ ANYseq \{ncomment ANYseq\} @-}@
ANYseq		-> \{ANY\}_{\{ANY\} ( @{-@ | @-}@ ) \{ANY\}}
ANY		-> any | newline | vertab | formfeed
any		-> graphic | space | tab
graphic		-> large | small | digit
 | @!@ | @"@ | @#@ | @$@ | @%@ | @&@  | \fwq | @(@ | @)@ | @*@ | @+@
 | @,@ | @-@ | @.@ | @/@ | @:@ | @;@  | @<@  | @=@ | @>@ | @?@ | @@
 | @[@ | @\@ | @]@ | @^@ | @_@ | \bkq | @{@  | @|@ | @}@ | @~@

small		-> @a@ | @b@ | ... | @z@
large		-> @A@ | @B@ | ... | @Z@
digit		-> @0@ | @1@ | ... | @9@
@@@
\indexsyn{program}%
\indexsyn{lexeme}%
\indexsyn{literal}%
\indexsyn{special}%
\indexsyn{whitespace}%
\indexsyn{whitestuff}%
\indexsyn{whitechar}%
\indexsyn{newline}%
\indexsyn{space}%
\indexsyn{tab}%
\indexsyn{vertab}%
\indexsyn{formfeed}%
\indexsyn{comment}%
\indexsyn{ncomment}%
\indexsyn{ANYseq}%
\indexsyn{ANY}%
\indexsyn{any}%
\indexsyn{graphic}%
\indexsyn{small}%
\indexsyn{large}%
\indexsyn{digit}%

Characters not in the category "graphic" or "whitestuff" are not valid
in \Haskell{} programs and should result in a lexing error.

Comments\index{comment} are valid "whitespace".  An ordinary
comment\index{comment!end-of-line} begins with two consecutive
dashes (@--@) and extends to the following newline.
A nested
comment\index{comment!nested} begins with @{-@ and ends with
@-}@; it can be between any two lexemes.
All character sequences not containing @{-@ nor @-}@
are ignored within a nested comment.
Nested comments may be
nested to any depth: any occurrence of @{-@ within the nested
comment starts a new nested comment, terminated by @-}@.  Within
a nested comment, each @{-@ is matched by a corresponding
occurrence of @-}@.  In an ordinary comment, the character
sequences @{-@ and @-}@ have no special significance, and, in a
nested comment, the sequence @--@ has no special significance.

If some code is commented out using a nested comment, then any
occurrence of @{-@ or @-}@ within a string or within an end-of-line
comment in that code will interfere with the nesting of the nested
comments.

\subsection{Identifiers and Operators}\index{identifier}\index{operator}
\label{ids}

@@@
avarid	-> (small \{small | large | digit | \fwq | @_@\})_{\{reservedid\}}
varid		-> avarid | @(@avarop@)@
aconid		-> large \{small | large | digit | \fwq | @_@\} 
conid		-> aconid | @(@aconop@)@
reservedid -> @case@ | @class@ | @data@ | @default@ | @deriving@ | @else@ | @hiding@
	| @if@ | @import@ | @in@ | @infix@ | @infixl@ | @infixr@ | @instance@ | @interface@
	| @let@ | @module@ | @of@ | @renaming@ | @then@ | @to@ | @type@ | @where@
@@@
\indexsyn{avarid}%
\indexsyn{varid}%
\indexsyn{aconid}%
\indexsyn{conid}%
\indexsyn{reservedid}%
An identifier consists of a letter followed by zero or more letters,
digits, underscores, and acute accents.  Identifiers are lexically
distinguished into two classes: those that begin with a small letter
(variable identifiers) and those that begin with a capital
(constructor identifiers).  Identifiers are case sensitive: @name@,
@naMe@, and @Name@ are three distinct identifiers (the first two are
variable identifiers, the last is a constructor identifier).

@@@
avarop		-> ( ( symbol | presymbol ) \{symbol | @:@\} )_{\{reservedop\}}
varop		-> avarop | \bkqB{avarid}\bkqA
aconop		-> (@:@ \{symbol | @:@\})_{\{reservedop\}}
conop		-> aconop | \bkqB{aconid}\bkqA
presymbol	-> @-@ | @~@
symbol		-> @!@ | @#@ | @$@ | @%@ | @&@ | @*@ | @+@ | @.@ | @/@ | @<@ | @=@ | @>@ | @?@ | @@ | @\@ | @^@ | @|@
reservedop	-> @..@ | @::@ | @=>@ | @=@ | @@ | @\@ | @|@ | @~@ | @<-@ | @->@
@@@
\indexsyn{avarop}%
\indexsyn{varop}%
\indexsyn{aconop}%
\indexsyn{conop}%
\indexsyn{presymbol}%
\indexsyn{symbol}%
\indexsyn{reservedop}%
An operator is either symbolic or alphanumeric.  Symbolic operators
are formed from one or more symbols, as defined above, and are
lexically distinguished into two classes: those that start with a
colon (constructors) and those that do not (functions).

Alphanumeric operators are formed by enclosing an identifier between
grave accents (backquotes).  Any variable or constructor may be used as
an operator in this way.  If "fun" is an identifier (either variable
or constructor), then an expression of the form "fun x y" is
equivalent to "x \bkqB{fun}\bkqA y".  If no fixity\index{fixity}
declaration is given for "\bkqB{fun}\bkqA" then it defaults
to highest precedence and left associativity
(see Section~\ref{fixity}).

Similarly, any symbolic operator may be used as a (curried) variable
or constructor by enclosing it in parentheses.  If "op" is an infix
operator, then an expression or pattern of the form \mbox{"x op y"} is
equivalent to {"@(@op@)@ x y"}.

No white space is permitted in names such as "\bkqB{fun}\bkqA" and
"@(@op@)@".

Other than the special syntax for prefix negation, all operators are
infix, although each infix operator can be used in a {\em
section}\index{section} to yield partially applied operators (see
Section~\ref{sections}).
All of the standard infix operators are just
predefined symbols and may be rebound.

Although @case@ is a reserved word, @cases@ is not.
Similarly, although @=@ is reserved, @==@ and @~=@ are
not.  At each point, the longest possible lexeme
\index{longest lexeme rule}
is read, using a context-independent deterministic lexical analysis
(i.e.~no lookahead beyond the current character is required).
Any kind of "whitespace" is also a proper delimiter for lexemes.

In the remainder of the report six different kinds of 
names\index{namespaces} will be used:
@@@
var	->  varid 	& (variables)
con	->  conid 	& (constructors)
tyvar	->  avarid	& (type variables)
tycon	->  aconid 	& (type constructors)
tycls	->  aconid 	& (type classes)
modid   ->  aconid	& (modules)
@@@
\indexsyn{var}%
\indexsyn{con}%
\indexsyn{tyvar}%
\indexsyn{tycon}%
\indexsyn{tycls}%
\indexsyn{modid}%
Variables and type variables are represented by identifiers beginning
with small letters, and the other four by identifiers beginning with
capitals; also, variables and constructors have infix forms, the other
four do not.  Namespaces are also discussed in
Section~\ref{namespaces}.

\subsection{Numeric Literals}\index{number!literal syntax}
\label{lexemes-numeric}

@@@
integer		-> digit\{digit\}
float		-> integer@.@integer[(@e@ | @E@)[@-@ | @+@]integer]
@@@
\indexsyn{integer}%
\indexsyn{float}%
There are two distinct kinds of numeric literals: integer and
floating.  A floating literal must contain digits both before and
after the decimal point; this ensures that a decimal point cannot be
mistaken for another use of the dot character.  Negative numeric
literals are discussed in Section~\ref{operators}.  The typing of
numeric literals is discussed in Section~\ref{numeric-literals}.

\subsection{Character and String Literals}
\index{character!literal syntax}
\index{string!literal syntax}
\label{lexemes-char}

@@@
char    ->  \fwq (graphic_{\{\fwq | @\@\}} | space | escape_{\{@\&@\}}) \fwq
string  ->  @"@ \{graphic_{\{@"@  | @\@\}} | space | escape | gap\} @"@
escape  ->  @\@ ( charesc | ascii | integer | @o@ octit\{octit\} | @x@ hexit\{hexit\} )
charesc -> @a@ | @b@ | @f@ | @n@ | @r@ | @t@ | @v@ | @\@ | @"@ | \fwq | @&@
ascii   -> @^@cntrl | @NUL@ | @SOH@ | @STX@ | @ETX@ | @EOT@ | @ENQ@ | @ACK@ 
       | @BEL@ | @BS@ | @HT@ | @LF@ | @VT@ | @FF@ | @CR@ | @SO@ | @SI@ | @DLE@ 
       | @DC1@ | @DC2@ | @DC3@ | @DC4@ | @NAK@ | @SYN@ | @ETB@ | @CAN@ 
       | @EM@ | @SUB@ | @ESC@ | @FS@ | @GS@ | @RS@ | @US@ | @SP@ | @DEL@
cntrl   -> large | @@ | @[@ | @\@ | @]@ | @^@ | @_@
gap     ->  @\@ whitechar \{whitechar\} @\@
hexit   -> digit | @A@ | @B@ | @C@ | @D@ | @E@ | @F@ | @a@ | @b@ | @c@ | @d@ | @e@ | @f@
octit   -> @0@ | @1@ | @2@ | @3@ | @4@ | @5@ | @6@ | @7@
@@@
\indexsyn{char}%
\indexsyn{string}%
\indexsyn{escape}%
\indexsyn{charesc}%
\indexsyn{ascii}%
\indexsyn{cntrl}%
\indexsyn{gap}%
\indexsyn{hexit}%
\indexsyn{octit}%

Character literals are written between acute accents, as in
\fwq@a@\fwq, and strings between double quotes, as in @"Hello"@.

Escape codes may be used in characters and strings to represent
special characters.  Note that \fwq\ may be used in a string, but
must be escaped in a character; similarly, @"@ may be used in a
character, but must be escaped in a string.  @\@ must always be
escaped.  The category "charesc" also includes portable
representations for the characters ``alert'' (@\a@), ``backspace''
(@\b@), ``form feed'' (@\f@), ``new line'' (@\n@), ``carriage return''
(@\r@), ``horizontal tab'' (@\t@), and ``vertical tab'' (@\v@).

Escape characters for the ASCII\index{ASCII character set} character
set, including
control characters such as @\^X@, are also provided.
Numeric escapes such as @\137@ are used to designate the character
with (implementation dependent) decimal representation 137; octal
(e.g.~@\o137@) and hexadecimal (e.g.~@\x137@) representations are also
allowed.  Numeric escapes that are out-of-range of the ASCII standard
are undefined and thus non-portable.

Consistent with the ``consume longest lexeme'' rule,
\index{longest lexeme rule}
numeric escape
characters in strings consist of all consecutive digits and may
be of arbitrary length.  Similarly, the one ambiguous ASCII escape
code, @"\SOH"@, is parsed as a string of length 1.  The escape
character @\&@ is provided as a ``null character'' to allow strings
such as @"\137\&9"@ and @"\SO\&H"@ to be constructed (both of length
two).  Thus @"\&"@ is equivalent to @""@ and the character
\fwq@\&@\fwq\ is disallowed.  Further equivalences of characters
are defined in Section~\ref{characters}.

A string may include a ``gap''---two backslants enclosing
white characters---which is ignored.
This allows one to write long strings on more than one line by writing
a backslant at the end of one line and at the start of the next.  For
example,
\bprog
@
"Here is a backslant \\ as well as \137, \
    \a numeric escape character, and \^X, a control character."
@
\eprogNoSkip

String literals are actually abbreviations for lists of characters
(see Section~\ref{lists}).

% Local Variables: 
% mode: latex
% End:
