%
% $Header$
%
\section{Syntax}
\label{syntax}
\index{syntax}

\subsection{Notational Conventions}

These notational conventions are used for presenting syntax:

\[\ba{cl}
"[pattern]"		& \tr{optional} \\
"\{pattern\}"		& \tr{zero or more repetitions} \\
"(pattern)"		& \tr{grouping} \\
"pat_1 | pat_2"		& \tr{choice} \\
"pat_{\{pat'\}}"	& \tr{difference---elements generated by "pat"} \\
			& \tr{except those generated by "pat'"} \\
"@fibonacci@"		& \tr{terminal syntax in typewriter font}
\ea\]

BNF-like syntax is used throughout, with productions having form:
@@@
nonterm		-> alt_1 | alt_2 | ... | alt_n
@@@

There are some families of nonterminals indexed by
precedence levels (written as a superscript).  Similarly, the
lexeme classes "op", "varop", and "conop" have a double index:  a letter "l",
"r", or "n" for left-, right- or nonassociativity and a precedence
level.  So, for example
@@@
exp^i	->   exp^{i+1} [op^{({\rm n},i)} exp^{i+1}]		(0<=i<=9)
@@@
actually stands for 10 productions where "op" is non-associative.

% here we input a list of the main changes in version 1.1
\input{syntax-changes-11}

\subsection{Lexical Syntax}

@@@
program		-> \{ lexeme | whitespace \}
lexeme          -> varid | conid | varop | conop | literal | special | reservedop | reservedid
literal		-> integer | float | char | string
special		-> @(@ | @)@ | @,@ | @;@ | @[@ | @]@ | @_@ | @{@ | @}@

whitespace	-> whitestuff \{whitestuff\}
whitestuff	-> whitechar | comment | ncomment
whitechar	-> newline | space | tab | vertab | formfeed
newline		-> \tr{a newline (system dependent)}
space		-> \tr{a space}
tab		-> \tr{a horizontal tab}
vertab		-> \tr{a vertical tab}
formfeed	-> \tr{a form feed}
comment		-> @--@ \{any\} newline
ncomment	-> @{-@ ANYseq \{ncomment ANYseq\} @-}@
ANYseq		-> \{ANY\}_{\{ANY\} ( @{-@ | @-}@ ) \{ANY\}}
ANY		-> any | newline | vertab | formfeed
any		-> graphic | space | tab
graphic		-> large | small | digit
 | @!@ | @"@ | @#@ | @$@ | @%@ | @&@  | \fwq | @(@ | @)@ | @*@ | @+@
 | @,@ | @-@ | @.@ | @/@ | @:@ | @;@  | @<@  | @=@ | @>@ | @?@ | @@
 | @[@ | @\@ | @]@ | @^@ | @_@ | \bkq | @{@  | @|@ | @}@ | @~@

small		-> @a@ | @b@ | ... | @z@
large		-> @A@ | @B@ | ... | @Z@
digit		-> @0@ | @1@ | ... | @9@
@@@
\indexsyn{program}%
\indexsyn{lexeme}%
\indexsyn{literal}%
\indexsyn{special}%
\indexsyn{whitespace}%
\indexsyn{whitestuff}%
\indexsyn{whitechar}%
\indexsyn{newline}%
\indexsyn{space}%
\indexsyn{tab}%
\indexsyn{vertab}%
\indexsyn{formfeed}%
\indexsyn{comment}%
\indexsyn{ncomment}%
\indexsyn{ANYseq}%
\indexsyn{ANY}%
\indexsyn{any}%
\indexsyn{graphic}%
\indexsyn{small}%
\indexsyn{large}%
\indexsyn{digit}%

@@@
avarid	-> (small \{small | large | digit | \fwq | @_@\})_{\{reservedid\}}
varid		-> avarid | @(@avarop@)@
aconid		-> large \{small | large | digit | \fwq | @_@\} 
conid		-> aconid | @(@aconop@)@
reservedid -> @case@ | @class@ | @data@ | @default@ | @deriving@ | @else@ | @hiding@
	| @if@ | @import@ | @in@ | @infix@ | @infixl@ | @infixr@ | @instance@ | @interface@
	| @let@ | @module@ | @of@ | @renaming@ | @then@ | @to@ | @type@ | @where@
@@@
\indexsyn{avarid}%
\indexsyn{varid}%
\indexsyn{aconid}%
\indexsyn{conid}%
\indexsyn{reservedid}%

@@@
avarop		-> ( ( symbol | presymbol ) \{symbol | @:@\} )_{\{reservedop\}}
varop		-> avarop | \bkqB{avarid}\bkqA
aconop		-> (@:@ \{symbol | @:@\})_{\{reservedop\}}
conop		-> aconop | \bkqB{aconid}\bkqA
presymbol	-> @-@ | @~@
symbol		-> @!@ | @#@ | @$@ | @%@ | @&@ | @*@ | @+@ | @.@ | @/@ | @<@ | @=@ | @>@ | @?@ | @@ | @\@ | @^@ | @|@
reservedop	-> @..@ | @::@ | @=>@ | @=@ | @@ | @\@ | @|@ | @~@ | @<-@ | @->@
@@@
\indexsyn{avarop}%
\indexsyn{varop}%
\indexsyn{aconop}%
\indexsyn{conop}%
\indexsyn{presymbol}%
\indexsyn{symbol}%
\indexsyn{reservedop}%

@@@
var	->  varid 	& (variables)
con	->  conid 	& (constructors)
tyvar	->  avarid	& (type variables)
tycon	->  aconid 	& (type constructors)
tycls	->  aconid 	& (type classes)
modid   ->  aconid	& (modules)
@@@
\indexsyn{var}%
\indexsyn{con}%
\indexsyn{tyvar}%
\indexsyn{tycon}%
\indexsyn{tycls}%
\indexsyn{modid}%

@@@
integer		-> digit\{digit\}
float		-> integer@.@integer[(@e@ | @E@)[@-@ | @+@]integer]
@@@
\indexsyn{integer}%
\indexsyn{float}%

@@@
char    ->  \fwq (graphic_{\{\fwq | @\@\}} | space | escape_{\{@\&@\}}) \fwq
string  ->  @"@ \{graphic_{\{@"@  | @\@\}} | space | escape | gap\} @"@
escape  ->  @\@ ( charesc | ascii | integer | @o@ octit\{octit\} | @x@ hexit\{hexit\} )
charesc -> @a@ | @b@ | @f@ | @n@ | @r@ | @t@ | @v@ | @\@ | @"@ | \fwq | @&@
ascii   -> @^@cntrl | @NUL@ | @SOH@ | @STX@ | @ETX@ | @EOT@ | @ENQ@ | @ACK@ 
       | @BEL@ | @BS@ | @HT@ | @LF@ | @VT@ | @FF@ | @CR@ | @SO@ | @SI@ | @DLE@ 
       | @DC1@ | @DC2@ | @DC3@ | @DC4@ | @NAK@ | @SYN@ | @ETB@ | @CAN@ 
       | @EM@ | @SUB@ | @ESC@ | @FS@ | @GS@ | @RS@ | @US@ | @SP@ | @DEL@
cntrl   -> large | @@ | @[@ | @\@ | @]@ | @^@ | @_@
gap     ->  @\@ whitechar \{whitechar\} @\@
hexit   -> digit | @A@ | @B@ | @C@ | @D@ | @E@ | @F@ | @a@ | @b@ | @c@ | @d@ | @e@ | @f@
octit   -> @0@ | @1@ | @2@ | @3@ | @4@ | @5@ | @6@ | @7@
@@@
\indexsyn{char}%
\indexsyn{string}%
\indexsyn{escape}%
\indexsyn{charesc}%
\indexsyn{ascii}%
\indexsyn{cntrl}%
\indexsyn{gap}%
\indexsyn{hexit}%
\indexsyn{octit}%

\subsection{Layout}
\label{layout}
\index{layout}

Definitions: The indentation of a lexeme is the column number
indicating the start of that lexeme; the indentation of a line is the
indentation of its leftmost lexeme.  To determine the column number,
assume a fixed-width font with this tab convention: tab stops
are 8 characters apart, and a tab character causes the insertion of
enough spaces to align the current position with the next tab stop.

In the syntax given in the other parts of the report, {\em declaration
lists} are always preceded by the keyword @where@ or @of@, and are
enclosed within curly braces (@{ }@) with the individual declarations
separated by semicolons (@;@).  For example, the syntax of a @let@
expression is:
\[
"let @{@ decl_1 @;@ decl_2 @;@ ... @;@ decl_n [@;@] @}@ in exp"
\]

\input{layout}

\subsection{Context-Free Syntax}
\label{bnf}

@@@ 
module -> @module@ modid [exports] @where@ body
       |  body
body   -> @{@ [impdecls @;@] [[fixdecls @;@] topdecls [@;@]] @}@
       |  @{@ impdecls [@;@] @}@

modid	     -> aconid
impdecls     -> impdecl_1 @;@ ... @;@ impdecl_n 	& \qquad (n>=1)
@@@ 
\indexsyn{module}%
\indexsyn{body}%
\indexsyn{modid}%
\indexsyn{impdecls}%

@@@
exports	     -> @(@ export_1 @,@ ... @,@ export_n @)@ & \qquad (n>=1)

export	 -> entity
         |  modid @..@
@@@
\indexsyn{exports}%
\indexsyn{export}%

@@@
impdecl   -> @import@ modid [impspec] [@renaming@ renamings] 
impspec   -> @(@ import_1 @,@ ... @,@ import_n @)@ & \qquad (n>=0)
             |  @hiding@ @(@ import_1 @,@ ... @,@ import_n @)@ & \qquad (n>=1)
import   -> entity
renamings -> @(@ renaming_1 @,@ ... @,@ renaming_n @)@	& \qquad (n>=1)
renaming -> varid_1 @to@ varid_2
	 |  conid_1 @to@ conid_2

entity   -> varid
         |  tycon
	 |  tycon @(..)@
         |  tycon @(@ conid_1 @,@ ... @,@ conid_n @)@	& \qquad (n>=1)
	 |  tycls @(..)@
	 |  tycls @(@ varid_1 @,@ ... @,@ varid_n @)@	& \qquad (n>=0)
@@@
\indexsyn{impdecl}%
\indexsyn{impspec}%
\indexsyn{import}%
\indexsyn{renamings}%
\indexsyn{renaming}%
\indexsyn{entity}%

@@@
fixdecls -> fix_1 @;@ ... @;@ fix_n 		& \qquad (n>=1)
fix	-> @infixl@ [digit] ops 
 	 | @infixr@ [digit] ops
  	 | @infix @ [digit] ops 
ops	-> op_1 @,@ ... @,@ op_n		& \qquad (n>=1)
op	-> varop | conop 
@@@
\indexsyn{fixdecls}%
\indexsyn{fix}%
\indexsyn{ops}%
\indexsyn{op}%

@@@
topdecls -> topdecl_1 @;@ ... @;@ topdecl_n 	& \qquad (n>=1)
topdecl	-> @type@ simple @=@ type
	| @data@ [context @=>@] simple @=@ constrs [@deriving@ (tycls | @(@tyclses@)@)]
	| @class@ [context @=>@] class [@where@ @{@ cbody [@;@] @}@]
	| @instance@ [context @=>@] tycls inst [@where@ @{@ valdefs [@;@] @}@]
	| @default@ (type | @(@type_1 @,@ ... @,@ type_n@)@) & \qquad (n>=0)
	| decl

decls	-> decl_1 @;@ ... @;@ decl_n		& \qquad (n>=0)
decl	-> vars @::@ [context @=>@] type	
	|  valdef
@@@
\indexsyn{topdecls}%
\indexsyn{topdecl}%
\indexsyn{decls}%
\indexsyn{decl}%

@@@
type	->  atype				
	|   type_1 @->@ type_2
	|   tycon atype_1 ... atype_k		& (\arity{tycon}=k>=1) 

atype	->  tyvar				
	|   tycon				& (\arity{tycon}=0) 
	|   @()@				& (\tr{unit type})
	|   @(@ type @)@			& (\tr{parenthesised type})
	|   @(@ type_1 @,@ ... @,@ type_k @)@	& (\tr{tuple type}, k>=2)
	|   @[@ type @]@			
@@@
\indexsyn{type}%
\indexsyn{atype}%

@@@
context -> class 
        |  @(@ class_1 @,@ ... @,@ class_n @)@		& (n>=1)
class	-> tycls tyvar			


cbody	-> [csigns @;@] [valdefs]
csigns	-> csign_1 @;@ ... @;@ csign_n 			& (n>=1)
csign	-> vars @::@ [context @=>@] type

vars	->  var_1 @,@ ...@,@ var_n			& (n>=1)
@@@
\indexsyn{context}%
\indexsyn{class}%
\indexsyn{cbody}%
\indexsyn{csigns}%
\indexsyn{csign}%
\indexsyn{vars}%

@@@
simple	->  tycon tyvar_1 ... tyvar_k		& (\arity{tycon}=k>=0) 
constrs	-> constr_1 @|@ ... @|@ constr_n	& (n>=1)
constr	-> con atype_1 ... atype_k		& (\arity{con}=k>=0)
	|  type_1 conop type_2			& (\infix{conop})
tyclses -> tycls_1@,@ ...@,@ tycls_n		& (n>=0)
@@@
\indexsyn{simple}%
\indexsyn{constrs}%
\indexsyn{constr}%
\indexsyn{tyclses}%

@@@
inst	-> tycon				& (\arity{tycon}=0)
	|  @(@ tycon tyvar_1 ... tyvar_k @)@	& (k>=1, tyvars {\rm distinct})
	|  @(@ tyvar_1 @,@ ... @,@ tyvar_k @)@	& (k>=2, tyvars {\rm distinct})
        |  @()@
	|  @[@ tyvar @]@
	|  @(@ tyvar_1 @->@ tyvar_2 @)@		& tyvar_1 {\rm and} tyvar_2 {\rm distinct}
@@@
\indexsyn{inst}%

@@@
valdefs ->  valdef_1 @;@ ... @;@ valdef_n 	& (n>=0)
valdef	->  lhs @=@ exp [@where@ @{@ decls [@;@] @}@]
	|   lhs gdrhs [@where@ @{@ decls [@;@] @}@]

lhs	->  apat
	|   funlhs
funlhs	->  afunlhs
	|   pat^{i+1}_1 varop^{({\rm n},i)} pat^{i+1}_2  & (0<=i<=9)
	|   lpat^i varop^{({\rm l},i)} pat^{i+1}	   & (0<=i<=9)
	|   pat^{i+1} varop^{({\rm r},i)} rpat^i	   & (0<=i<=9)
afunlhs ->  var apat
	|   @(@ funlhs @)@ apat
	|   afunlhs apat

gdrhs	->  gd @=@ exp [gdrhs]

gd	->  @|@ exp 
@@@
\indexsyn{valdefs}%
\indexsyn{valdef}%
\indexsyn{lhs}%
\indexsyn{funlhs}%
\indexsyn{afunlhs}%
\indexsyn{gdrhs}%
\indexsyn{gd}%

@@@
exp	->  @\@ apat_1 ... apat_n @->@ exp	& (\tr{lambda abstraction}, n>=1)
	|   @let@ @{@ decls [@;@] @}@ @in@ exp	& ({\tr{let expression}})
	|   @if@ exp @then@ exp @else@ exp	& (\tr{conditional})
	|   @case@ exp @of@ @{@ alts [@;@] @}@	& (\tr{case expression})
	|   exp^0 @::@ [context @=>@] atype	& (\tr{expression type signature})
        |   exp^0
exp^i	->  exp^{i+1} [op^{({\rm n},i)} exp^{i+1}]	& (0<=i<=9)
	|   lexp^i op^{({\rm l},i)} exp^{i+1}
	|   exp^{i+1} op^{({\rm r},i)} rexp^i
lexp^i	->  [lexp^i op^{({\rm l},i)}] exp^{i+1}	& (0<=i<=9)
lexp^6	->  @-@ exp^7
rexp^i	->  exp^{i+1} [op^{({\rm r},i)} rexp^i]	& (0<=i<=9)
exp^{10} -> exp^{10} aexp			& (\tr{function application})
         |  aexp
@@@
\indexsyn{exp}%
\index{exp@@"exp^i"}%
\index{lexp@@"lexp^i"}%
\index{rexp@@"rexp^i"}%

@@@
aexp	->  var					& (\tr{variable})
	|   con					& (\tr{constructor})
	|   literal				
	|   @()@				& (\tr{unit})
	|   @(@ exp @)@			      & (\tr{parenthesised expression})
	|   @(@ exp_1 @,@ ... @,@ exp_k @)@	& (\tr{tuple}, k>=2)
	|   @[@ exp_1 @,@ ... @,@ exp_k @]@	& (\tr{list}, k>=0)
	|   @[@ exp_1 [@,@ exp_2] @..@ [exp_3] @]@ & (\tr{arithmetic sequence})
	|   @[@ exp @|@ qual_1 @,@ ... @,@ qual_n @]@	& (\tr{list comprehension}, n>=1)
	|   @(@ exp^{i+1} op^{(a,i)} @)@        & (\tr{section}, 0<=i<=9, a\in\{n,l,r\})
        |   @(@ op^{(a,i)} exp^{i+1} @)@        & (\tr{section}, 0<=i<=9, a\in\{n,l,r\})
@@@
\indexsyn{aexp}%

@@@
qual	-> pat @<-@ exp 
         | exp 

alts	->  alt_1 @;@ ... @;@ alt_n 		& (n>=0)
alt	->  pat @->@ exp [@where@ @{@ decls [@;@] @}@]
	|   pat gdpat [@where@ @{@ decls [@;@] @}@]

gdpat   ->  gd @->@ exp [ gdpat ]
@@@
\indexsyn{qual}%
\indexsyn{alts}%
\indexsyn{alt}%
\indexsyn{gdpat}%

@@@
pat	->  pat^0
pat^i	->  pat^{i+1}_1 [conop^{({\rm n},i)} pat^{i+1}_2]	& (0<=i<=9)
	|   lpat^i conop^{({\rm l},i)} pat^{i+1}
	|   pat^{i+1} conop^{({\rm r},i)} rpat^i
lpat^i	->  [lpat^i conop^{({\rm l},i)}] pat^{i+1}	& (0<=i<=9)
lpat^6	->  lpat^6 @+@ integer			& (\tr{successor pattern})
	|   @-@ \{integer | float\}		& (\tr{negative literal})
rpat^i	->  pat^{i+1} [conop^{({\rm r},i)} rpat^i]	& (0<=i<=9)
pat^{10}->  apat
	|   con apat_1 ... apat_k		& (\arity{con}=k>=1)
@@@
\indexsyn{pat}%
\index{pat@@"pat^i"}%
\index{lpat@@"lpat^i"}%
\index{rpat@@"rpat^i"}%

@@@
apat	->  var [{\tt @@} apat]			& (\tr{as pattern})
	|   con					& (\arity{con}=0) 
	|   literal
	|   @_@					& (\tr{wildcard})
	|   @()@				& (\tr{unit pattern})
	|   @(@ pat @)@				& (\tr{parenthesised pattern})
	|   @(@ pat_1 @,@ ... @,@ pat_k @)@	& (\tr{tuple pattern}, k>=2)
	|   @[@ pat_1 @,@ ... @,@ pat_k @]@	& (\tr{list pattern}, k>=0) 
	|   @~@ apat				& (\tr{irrefutable pattern})
@@@
\indexsyn{apat}%

@@@
tycls	->  aconid
tyvar	->  avarid
tycon	->  aconid
@@@
\indexsyn{tycls}%
\indexsyn{tyvar}%
\indexsyn{tycon}%

\subsection{Interface Syntax}
\label{ibnf}

%
%interface-> @interface@ modid @where@ ibody
%
%ibody 	  -> @{@ [ [fixdecls @;@] itopdecls] @}@
%itopdecls -> itopdecl_1 @;@ ... @;@ itopdecl_n  & \qquad (n>=1) 
%itopdecl  -> @type@ simple @=@ type
%	   | @data@ [context @=>@] simple [@=@ constrs [@deriving@ (tycls | @(@tyclses@)@)]]
%	   | @class@ [context @=>@] class [@where@ @{@ icdecls [@;@] @}@]
%     	   | @instance@ [context @=>@] tycls inst
%     	   | vars @::@ [context @=>@] type
%icdecls	   -> icdecl_1 @;@ ... @;@ icdecl_n  & (n>=1)
%icdecl	   -> vars @::@ type
%

@@@
interface -> @interface@ modid @where@ ibody

ibody -> @{@ [iimpdecls @;@] [fixdecls @;@] itopdecls [@;@] @}@
      | @{@ iimpdecls [@;@] @}@
iimpdecls -> iimpdecl_1 @;@ ... @;@ iimpdecl_n	& \qquad (n>=1) 
iimpdecl   -> @import@ modid @(@ import_1 @,@ ... @,@ import_n @)@ 
	& [@renaming@ renamings] & \qquad (n>=1)
itopdecls -> itopdecl_1 @;@ ... @;@ itopdecl_n	& \qquad (n>=1) 
itopdecl  -> @type@ simple @=@ type
	| @data@ [context @=>@] simple [@=@ constrs] [@deriving@ (tycls | @(@tyclses@)@)]
	| @class@ [context @=>@] class [@where@ @{@ icdecls [@;@] @}@]
     	| @instance@ [context @=>@] tycls inst
     	| vars @::@ [context @=>@] type
icdecls	-> icdecl_1 @;@ ... @;@ icdecl_n	& (n>=1)
icdecl	-> vars @::@ type
@@@
\indexsyn{interface}%
\indexsyn{ibody}%
\indexsyn{iimpdecls}%
\indexsyn{iimpdecl}%
\indexsyn{itopdecls}%
\indexsyn{itopdecl}%
\indexsyn{icdecls}%
\indexsyn{icdecl}%

%In interface files, the syntax for "var", "tycon", and "tycls" is expanded 
%to include full names:\nopagebreak[4]
%
%var	->  varid [@{@modid [varid]@}@]		& (variables)
%tycon	->  aconid [@{@modid [aconid]@}@]	& (type constructors)
%tycls	->  aconid [@{@modid [aconid]@}@]	& (type classes)
%

%\input{syntax-changes-desc}

% Local Variables: 
% mode: latex
% End:
